{"ast":null,"code":"import _slicedToArray from \"/home/kudos-it/Documents/pro/ar/object_detection/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"/home/kudos-it/Documents/pro/ar/object_detection/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _classCallCheck from \"/home/kudos-it/Documents/pro/ar/object_detection/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/kudos-it/Documents/pro/ar/object_detection/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _asyncToGenerator from \"/home/kudos-it/Documents/pro/ar/object_detection/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as tfconv from '@tensorflow/tfjs-converter';\nimport * as tf from '@tensorflow/tfjs-core';\nimport { CLASSES } from './classes';\nvar BASE_PATH = 'https://storage.googleapis.com/tfjs-models/savedmodel/';\nexport { version } from './version';\nexport function load() {\n  return _load.apply(this, arguments);\n}\n\nfunction _load() {\n  _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n    var config,\n        base,\n        modelUrl,\n        objectDetection,\n        _args4 = arguments;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            config = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};\n\n            if (!(tf == null)) {\n              _context4.next = 3;\n              break;\n            }\n\n            throw new Error(\"Cannot find TensorFlow.js. If you are using a <script> tag, please \" + \"also include @tensorflow/tfjs on the page before using this model.\");\n\n          case 3:\n            base = config.base || 'lite_mobilenet_v2';\n            modelUrl = config.modelUrl;\n\n            if (!(['mobilenet_v1', 'mobilenet_v2', 'lite_mobilenet_v2'].indexOf(base) === -1)) {\n              _context4.next = 7;\n              break;\n            }\n\n            throw new Error(\"ObjectDetection constructed with invalid base model \" + \"\".concat(base, \". Valid names are 'mobilenet_v1',\") + \" 'mobilenet_v2' and 'lite_mobilenet_v2'.\");\n\n          case 7:\n            objectDetection = new ObjectDetection(base, modelUrl);\n            _context4.next = 10;\n            return objectDetection.load();\n\n          case 10:\n            return _context4.abrupt(\"return\", objectDetection);\n\n          case 11:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _load.apply(this, arguments);\n}\n\nexport var ObjectDetection = /*#__PURE__*/function () {\n  function ObjectDetection(base, modelUrl) {\n    _classCallCheck(this, ObjectDetection);\n\n    this.modelPath = modelUrl || \"\".concat(BASE_PATH).concat(this.getPrefix(base), \"/model.json\");\n  }\n\n  _createClass(ObjectDetection, [{\n    key: \"getPrefix\",\n    value: function getPrefix(base) {\n      return base === 'lite_mobilenet_v2' ? \"ssd\".concat(base) : \"ssd_\".concat(base);\n    }\n  }, {\n    key: \"load\",\n    value: function () {\n      var _load2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var zeroTensor, result;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return tfconv.loadGraphModel(this.modelPath);\n\n              case 2:\n                this.model = _context.sent;\n                zeroTensor = tf.zeros([1, 300, 300, 3], 'int32'); // Warmup the model.\n\n                _context.next = 6;\n                return this.model.executeAsync(zeroTensor);\n\n              case 6:\n                result = _context.sent;\n                _context.next = 9;\n                return Promise.all(result.map(function (t) {\n                  return t.data();\n                }));\n\n              case 9:\n                result.map(function (t) {\n                  return t.dispose();\n                });\n                zeroTensor.dispose();\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function load() {\n        return _load2.apply(this, arguments);\n      }\n\n      return load;\n    }()\n    /**\n     * Infers through the model.\n     *\n     * @param img The image to classify. Can be a tensor or a DOM element image,\n     * video, or canvas.\n     * @param maxNumBoxes The maximum number of bounding boxes of detected\n     * objects. There can be multiple objects of the same class, but at different\n     * locations. Defaults to 20.\n     * @param minScore The minimum score of the returned bounding boxes\n     * of detected objects. Value between 0 and 1. Defaults to 0.5.\n     */\n\n  }, {\n    key: \"infer\",\n    value: function () {\n      var _infer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(img, maxNumBoxes, minScore) {\n        var batched, height, width, result, scores, boxes, _this$calculateMaxSco, _this$calculateMaxSco2, maxScores, classes, prevBackend, indexTensor, indexes;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                batched = tf.tidy(function () {\n                  if (!(img instanceof tf.Tensor)) {\n                    img = tf.browser.fromPixels(img);\n                  } // Reshape to a single-element batch so we can pass it to executeAsync.\n\n\n                  return img.expandDims(0);\n                });\n                height = batched.shape[1];\n                width = batched.shape[2]; // model returns two tensors:\n                // 1. box classification score with shape of [1, 1917, 90]\n                // 2. box location with shape of [1, 1917, 1, 4]\n                // where 1917 is the number of box detectors, 90 is the number of classes.\n                // and 4 is the four coordinates of the box.\n\n                _context2.next = 5;\n                return this.model.executeAsync(batched);\n\n              case 5:\n                result = _context2.sent;\n                scores = result[0].dataSync();\n                boxes = result[1].dataSync(); // clean the webgl tensors\n\n                batched.dispose();\n                tf.dispose(result);\n                _this$calculateMaxSco = this.calculateMaxScores(scores, result[0].shape[1], result[0].shape[2]), _this$calculateMaxSco2 = _slicedToArray(_this$calculateMaxSco, 2), maxScores = _this$calculateMaxSco2[0], classes = _this$calculateMaxSco2[1];\n                prevBackend = tf.getBackend(); // run post process in cpu\n\n                tf.setBackend('cpu');\n                indexTensor = tf.tidy(function () {\n                  var boxes2 = tf.tensor2d(boxes, [result[1].shape[1], result[1].shape[3]]);\n                  return tf.image.nonMaxSuppression(boxes2, maxScores, maxNumBoxes, minScore, minScore);\n                });\n                indexes = indexTensor.dataSync();\n                indexTensor.dispose(); // restore previous backend\n\n                tf.setBackend(prevBackend);\n                return _context2.abrupt(\"return\", this.buildDetectedObjects(width, height, boxes, maxScores, indexes, classes));\n\n              case 18:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function infer(_x, _x2, _x3) {\n        return _infer.apply(this, arguments);\n      }\n\n      return infer;\n    }()\n  }, {\n    key: \"buildDetectedObjects\",\n    value: function buildDetectedObjects(width, height, boxes, scores, indexes, classes) {\n      var count = indexes.length;\n      var objects = [];\n\n      for (var i = 0; i < count; i++) {\n        var bbox = [];\n\n        for (var j = 0; j < 4; j++) {\n          bbox[j] = boxes[indexes[i] * 4 + j];\n        }\n\n        var minY = bbox[0] * height;\n        var minX = bbox[1] * width;\n        var maxY = bbox[2] * height;\n        var maxX = bbox[3] * width;\n        bbox[0] = minX;\n        bbox[1] = minY;\n        bbox[2] = maxX - minX;\n        bbox[3] = maxY - minY;\n        objects.push({\n          bbox: bbox,\n          class: CLASSES[classes[indexes[i]] + 1].displayName,\n          score: scores[indexes[i]]\n        });\n      }\n\n      return objects;\n    }\n  }, {\n    key: \"calculateMaxScores\",\n    value: function calculateMaxScores(scores, numBoxes, numClasses) {\n      var maxes = [];\n      var classes = [];\n\n      for (var i = 0; i < numBoxes; i++) {\n        var max = Number.MIN_VALUE;\n        var index = -1;\n\n        for (var j = 0; j < numClasses; j++) {\n          if (scores[i * numClasses + j] > max) {\n            max = scores[i * numClasses + j];\n            index = j;\n          }\n        }\n\n        maxes[i] = max;\n        classes[i] = index;\n      }\n\n      return [maxes, classes];\n    }\n    /**\n     * Detect objects for an image returning a list of bounding boxes with\n     * assocated class and score.\n     *\n     * @param img The image to detect objects from. Can be a tensor or a DOM\n     *     element image, video, or canvas.\n     * @param maxNumBoxes The maximum number of bounding boxes of detected\n     * objects. There can be multiple objects of the same class, but at different\n     * locations. Defaults to 20.\n     * @param minScore The minimum score of the returned bounding boxes\n     * of detected objects. Value between 0 and 1. Defaults to 0.5.\n     */\n\n  }, {\n    key: \"detect\",\n    value: function () {\n      var _detect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(img) {\n        var maxNumBoxes,\n            minScore,\n            _args3 = arguments;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                maxNumBoxes = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : 20;\n                minScore = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : 0.5;\n                return _context3.abrupt(\"return\", this.infer(img, maxNumBoxes, minScore));\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function detect(_x4) {\n        return _detect.apply(this, arguments);\n      }\n\n      return detect;\n    }()\n    /**\n     * Dispose the tensors allocated by the model. You should call this when you\n     * are done with the model.\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      if (this.model != null) {\n        this.model.dispose();\n      }\n    }\n  }]);\n\n  return ObjectDetection;\n}();","map":{"version":3,"sources":["/home/kudos-it/Documents/pro/ar/object_detection/node_modules/@tensorflow-models/coco-ssd/dist/index.js"],"names":["tfconv","tf","CLASSES","BASE_PATH","version","load","config","Error","base","modelUrl","indexOf","objectDetection","ObjectDetection","modelPath","getPrefix","loadGraphModel","model","zeroTensor","zeros","executeAsync","result","Promise","all","map","t","data","dispose","img","maxNumBoxes","minScore","batched","tidy","Tensor","browser","fromPixels","expandDims","height","shape","width","scores","dataSync","boxes","calculateMaxScores","maxScores","classes","prevBackend","getBackend","setBackend","indexTensor","boxes2","tensor2d","image","nonMaxSuppression","indexes","buildDetectedObjects","count","length","objects","i","bbox","j","minY","minX","maxY","maxX","push","class","displayName","score","numBoxes","numClasses","maxes","max","Number","MIN_VALUE","index","infer"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as tfconv from '@tensorflow/tfjs-converter';\nimport * as tf from '@tensorflow/tfjs-core';\nimport { CLASSES } from './classes';\nconst BASE_PATH = 'https://storage.googleapis.com/tfjs-models/savedmodel/';\nexport { version } from './version';\nexport async function load(config = {}) {\n    if (tf == null) {\n        throw new Error(`Cannot find TensorFlow.js. If you are using a <script> tag, please ` +\n            `also include @tensorflow/tfjs on the page before using this model.`);\n    }\n    const base = config.base || 'lite_mobilenet_v2';\n    const modelUrl = config.modelUrl;\n    if (['mobilenet_v1', 'mobilenet_v2', 'lite_mobilenet_v2'].indexOf(base) ===\n        -1) {\n        throw new Error(`ObjectDetection constructed with invalid base model ` +\n            `${base}. Valid names are 'mobilenet_v1',` +\n            ` 'mobilenet_v2' and 'lite_mobilenet_v2'.`);\n    }\n    const objectDetection = new ObjectDetection(base, modelUrl);\n    await objectDetection.load();\n    return objectDetection;\n}\nexport class ObjectDetection {\n    constructor(base, modelUrl) {\n        this.modelPath =\n            modelUrl || `${BASE_PATH}${this.getPrefix(base)}/model.json`;\n    }\n    getPrefix(base) {\n        return base === 'lite_mobilenet_v2' ? `ssd${base}` : `ssd_${base}`;\n    }\n    async load() {\n        this.model = await tfconv.loadGraphModel(this.modelPath);\n        const zeroTensor = tf.zeros([1, 300, 300, 3], 'int32');\n        // Warmup the model.\n        const result = await this.model.executeAsync(zeroTensor);\n        await Promise.all(result.map(t => t.data()));\n        result.map(t => t.dispose());\n        zeroTensor.dispose();\n    }\n    /**\n     * Infers through the model.\n     *\n     * @param img The image to classify. Can be a tensor or a DOM element image,\n     * video, or canvas.\n     * @param maxNumBoxes The maximum number of bounding boxes of detected\n     * objects. There can be multiple objects of the same class, but at different\n     * locations. Defaults to 20.\n     * @param minScore The minimum score of the returned bounding boxes\n     * of detected objects. Value between 0 and 1. Defaults to 0.5.\n     */\n    async infer(img, maxNumBoxes, minScore) {\n        const batched = tf.tidy(() => {\n            if (!(img instanceof tf.Tensor)) {\n                img = tf.browser.fromPixels(img);\n            }\n            // Reshape to a single-element batch so we can pass it to executeAsync.\n            return img.expandDims(0);\n        });\n        const height = batched.shape[1];\n        const width = batched.shape[2];\n        // model returns two tensors:\n        // 1. box classification score with shape of [1, 1917, 90]\n        // 2. box location with shape of [1, 1917, 1, 4]\n        // where 1917 is the number of box detectors, 90 is the number of classes.\n        // and 4 is the four coordinates of the box.\n        const result = await this.model.executeAsync(batched);\n        const scores = result[0].dataSync();\n        const boxes = result[1].dataSync();\n        // clean the webgl tensors\n        batched.dispose();\n        tf.dispose(result);\n        const [maxScores, classes] = this.calculateMaxScores(scores, result[0].shape[1], result[0].shape[2]);\n        const prevBackend = tf.getBackend();\n        // run post process in cpu\n        tf.setBackend('cpu');\n        const indexTensor = tf.tidy(() => {\n            const boxes2 = tf.tensor2d(boxes, [result[1].shape[1], result[1].shape[3]]);\n            return tf.image.nonMaxSuppression(boxes2, maxScores, maxNumBoxes, minScore, minScore);\n        });\n        const indexes = indexTensor.dataSync();\n        indexTensor.dispose();\n        // restore previous backend\n        tf.setBackend(prevBackend);\n        return this.buildDetectedObjects(width, height, boxes, maxScores, indexes, classes);\n    }\n    buildDetectedObjects(width, height, boxes, scores, indexes, classes) {\n        const count = indexes.length;\n        const objects = [];\n        for (let i = 0; i < count; i++) {\n            const bbox = [];\n            for (let j = 0; j < 4; j++) {\n                bbox[j] = boxes[indexes[i] * 4 + j];\n            }\n            const minY = bbox[0] * height;\n            const minX = bbox[1] * width;\n            const maxY = bbox[2] * height;\n            const maxX = bbox[3] * width;\n            bbox[0] = minX;\n            bbox[1] = minY;\n            bbox[2] = maxX - minX;\n            bbox[3] = maxY - minY;\n            objects.push({\n                bbox: bbox,\n                class: CLASSES[classes[indexes[i]] + 1].displayName,\n                score: scores[indexes[i]]\n            });\n        }\n        return objects;\n    }\n    calculateMaxScores(scores, numBoxes, numClasses) {\n        const maxes = [];\n        const classes = [];\n        for (let i = 0; i < numBoxes; i++) {\n            let max = Number.MIN_VALUE;\n            let index = -1;\n            for (let j = 0; j < numClasses; j++) {\n                if (scores[i * numClasses + j] > max) {\n                    max = scores[i * numClasses + j];\n                    index = j;\n                }\n            }\n            maxes[i] = max;\n            classes[i] = index;\n        }\n        return [maxes, classes];\n    }\n    /**\n     * Detect objects for an image returning a list of bounding boxes with\n     * assocated class and score.\n     *\n     * @param img The image to detect objects from. Can be a tensor or a DOM\n     *     element image, video, or canvas.\n     * @param maxNumBoxes The maximum number of bounding boxes of detected\n     * objects. There can be multiple objects of the same class, but at different\n     * locations. Defaults to 20.\n     * @param minScore The minimum score of the returned bounding boxes\n     * of detected objects. Value between 0 and 1. Defaults to 0.5.\n     */\n    async detect(img, maxNumBoxes = 20, minScore = 0.5) {\n        return this.infer(img, maxNumBoxes, minScore);\n    }\n    /**\n     * Dispose the tensors allocated by the model. You should call this when you\n     * are done with the model.\n     */\n    dispose() {\n        if (this.model != null) {\n            this.model.dispose();\n        }\n    }\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}