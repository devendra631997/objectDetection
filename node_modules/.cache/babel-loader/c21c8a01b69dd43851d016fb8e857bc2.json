{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { customGrad } from '../gradients';\nimport { convertToTensor } from '../tensor_util_env';\nimport { parseAxisParam, sizeFromShape } from '../util';\nimport { computeOutAndReduceShapes } from './axis_util';\nimport { cast } from './cast';\nimport { div } from './div';\nimport { mul } from './mul';\nimport { ones } from './ones';\nimport { op } from './operation';\nimport { reshape } from './reshape';\nimport { scalar } from './scalar';\nimport { sum } from './sum';\n/**\n * Computes the mean of elements across dimensions of a `tf.Tensor`.\n *\n * Reduces `x` along the dimensions given in `axis`. Unless `keepDims` is\n * true, the rank of the `tf.Tensor` is reduced by 1 for each entry in `axis`.\n * If `keepDims` is true, the reduced dimensions are retained with length 1.\n * If `axis` has no entries, all dimensions are reduced, and a `tf.Tensor` with\n * a single element is returned.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3]);\n *\n * x.mean().print();  // or tf.mean(a)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * const axis = 1;\n * x.mean(axis).print();  // or tf.mean(x, axis)\n * ```\n *\n * @param x The input tensor.\n * @param axis The dimension(s) to reduce. By default it reduces\n *     all dimensions.\n * @param keepDims If true, retains reduced dimensions with size 1.\n *\n * @doc {heading: 'Operations', subheading: 'Reduction'}\n */\n\nfunction mean_(x) {\n  var axis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var keepDims = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var $x = convertToTensor(x, 'x', 'mean');\n  var axes = parseAxisParam(axis, $x.shape);\n  var shapes = computeOutAndReduceShapes($x.shape, axes);\n  var reduceShape = shapes[1];\n  var reduceSize = sizeFromShape(reduceShape); // Use a custom gradient to bypass 2 gradient backprops since mean is used\n  // extremely often.\n\n  var customOp = customGrad(function (x) {\n    var reduceSizeScalar = scalar(reduceSize); // Cast if needed.\n\n    var xReduce = reduceSizeScalar.dtype === x.dtype ? x : cast(x, reduceSizeScalar.dtype);\n    var res = div(xReduce, reduceSizeScalar);\n    var value = sum(res, axis, keepDims);\n\n    var gradFunc = function gradFunc(dy) {\n      var expandedDyShape = x.shape.slice();\n      axes.forEach(function (axis) {\n        expandedDyShape[axis] = 1;\n      });\n      var expandedDy = reshape(dy, expandedDyShape);\n      var derX = div(mul(expandedDy, ones(x.shape, 'float32')), reduceSize);\n      return derX;\n    };\n\n    return {\n      value: value,\n      gradFunc: gradFunc\n    };\n  });\n  return customOp($x);\n}\n\nexport var mean = op({\n  mean_: mean_\n});","map":{"version":3,"sources":["../../src/ops/mean.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA,SAAQ,UAAR,QAAyB,cAAzB;AAEA,SAAQ,eAAR,QAA8B,oBAA9B;AAEA,SAAQ,cAAR,EAAwB,aAAxB,QAA4C,SAA5C;AAEA,SAAQ,yBAAR,QAAwC,aAAxC;AACA,SAAQ,IAAR,QAAmB,QAAnB;AACA,SAAQ,GAAR,QAAkB,OAAlB;AACA,SAAQ,GAAR,QAAkB,OAAlB;AACA,SAAQ,IAAR,QAAmB,QAAnB;AACA,SAAQ,EAAR,QAAiB,aAAjB;AACA,SAAQ,OAAR,QAAsB,WAAtB;AACA,SAAQ,MAAR,QAAqB,UAArB;AACA,SAAQ,GAAR,QAAkB,OAAlB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA,SAAS,KAAT,CACI,CADJ,EACwE;AAAA,MAA9C,IAA8C,uEAAtB,IAAsB;AAAA,MAAhB,QAAgB,uEAAL,KAAK;AACtE,MAAM,EAAE,GAAG,eAAe,CAAC,CAAD,EAAI,GAAJ,EAAS,MAAT,CAA1B;AAEA,MAAM,IAAI,GAAG,cAAc,CAAC,IAAD,EAAO,EAAE,CAAC,KAAV,CAA3B;AACA,MAAM,MAAM,GAAG,yBAAyB,CAAC,EAAE,CAAC,KAAJ,EAAW,IAAX,CAAxC;AACA,MAAM,WAAW,GAAG,MAAM,CAAC,CAAD,CAA1B;AACA,MAAM,UAAU,GAAG,aAAa,CAAC,WAAD,CAAhC,CANsE,CAQtE;AACA;;AACA,MAAM,QAAQ,GAAG,UAAU,CAAC,UAAC,CAAD,EAAc;AACxC,QAAM,gBAAgB,GAAG,MAAM,CAAC,UAAD,CAA/B,CADwC,CAExC;;AACA,QAAM,OAAO,GAAG,gBAAgB,CAAC,KAAjB,KAA2B,CAAC,CAAC,KAA7B,GACZ,CADY,GAEZ,IAAI,CAAC,CAAD,EAAI,gBAAgB,CAAC,KAArB,CAFR;AAGA,QAAM,GAAG,GAAG,GAAG,CAAC,OAAD,EAAU,gBAAV,CAAf;AACA,QAAM,KAAK,GAAG,GAAG,CAAC,GAAD,EAAM,IAAN,EAAY,QAAZ,CAAjB;;AAEA,QAAM,QAAQ,GAAG,SAAX,QAAW,CAAC,EAAD,EAAe;AAC9B,UAAM,eAAe,GAAG,CAAC,CAAC,KAAF,CAAQ,KAAR,EAAxB;AACA,MAAA,IAAI,CAAC,OAAL,CAAa,UAAA,IAAI,EAAG;AAClB,QAAA,eAAe,CAAC,IAAD,CAAf,GAAwB,CAAxB;AACD,OAFD;AAGA,UAAM,UAAU,GAAG,OAAO,CAAC,EAAD,EAAK,eAAL,CAA1B;AACA,UAAM,IAAI,GAAG,GAAG,CAAC,GAAG,CAAC,UAAD,EAAa,IAAI,CAAC,CAAC,CAAC,KAAH,EAAU,SAAV,CAAjB,CAAJ,EAA4C,UAA5C,CAAhB;AACA,aAAO,IAAP;AACD,KARD;;AASA,WAAO;AAAC,MAAA,KAAK,EAAL,KAAD;AAAQ,MAAA,QAAQ,EAAR;AAAR,KAAP;AACD,GAnB0B,CAA3B;AAqBA,SAAO,QAAQ,CAAC,EAAD,CAAf;AACD;;AAED,OAAO,IAAM,IAAI,GAAG,EAAE,CAAC;AAAC,EAAA,KAAK,EAAL;AAAD,CAAD,CAAf","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { customGrad } from '../gradients';\nimport { convertToTensor } from '../tensor_util_env';\nimport { parseAxisParam, sizeFromShape } from '../util';\nimport { computeOutAndReduceShapes } from './axis_util';\nimport { cast } from './cast';\nimport { div } from './div';\nimport { mul } from './mul';\nimport { ones } from './ones';\nimport { op } from './operation';\nimport { reshape } from './reshape';\nimport { scalar } from './scalar';\nimport { sum } from './sum';\n/**\n * Computes the mean of elements across dimensions of a `tf.Tensor`.\n *\n * Reduces `x` along the dimensions given in `axis`. Unless `keepDims` is\n * true, the rank of the `tf.Tensor` is reduced by 1 for each entry in `axis`.\n * If `keepDims` is true, the reduced dimensions are retained with length 1.\n * If `axis` has no entries, all dimensions are reduced, and a `tf.Tensor` with\n * a single element is returned.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3]);\n *\n * x.mean().print();  // or tf.mean(a)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * const axis = 1;\n * x.mean(axis).print();  // or tf.mean(x, axis)\n * ```\n *\n * @param x The input tensor.\n * @param axis The dimension(s) to reduce. By default it reduces\n *     all dimensions.\n * @param keepDims If true, retains reduced dimensions with size 1.\n *\n * @doc {heading: 'Operations', subheading: 'Reduction'}\n */\nfunction mean_(x, axis = null, keepDims = false) {\n    const $x = convertToTensor(x, 'x', 'mean');\n    const axes = parseAxisParam(axis, $x.shape);\n    const shapes = computeOutAndReduceShapes($x.shape, axes);\n    const reduceShape = shapes[1];\n    const reduceSize = sizeFromShape(reduceShape);\n    // Use a custom gradient to bypass 2 gradient backprops since mean is used\n    // extremely often.\n    const customOp = customGrad((x) => {\n        const reduceSizeScalar = scalar(reduceSize);\n        // Cast if needed.\n        const xReduce = reduceSizeScalar.dtype === x.dtype ?\n            x :\n            cast(x, reduceSizeScalar.dtype);\n        const res = div(xReduce, reduceSizeScalar);\n        const value = sum(res, axis, keepDims);\n        const gradFunc = (dy) => {\n            const expandedDyShape = x.shape.slice();\n            axes.forEach(axis => {\n                expandedDyShape[axis] = 1;\n            });\n            const expandedDy = reshape(dy, expandedDyShape);\n            const derX = div(mul(expandedDy, ones(x.shape, 'float32')), reduceSize);\n            return derX;\n        };\n        return { value, gradFunc };\n    });\n    return customOp($x);\n}\nexport const mean = op({ mean_ });\n//# sourceMappingURL=mean.js.map"]},"metadata":{},"sourceType":"module"}