{"ast":null,"code":"import _slicedToArray from \"/home/kudos-it/Documents/pro/ar/object_detection/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/home/kudos-it/Documents/pro/ar/object_detection/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"/home/kudos-it/Documents/pro/ar/object_detection/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/kudos-it/Documents/pro/ar/object_detection/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/home/kudos-it/Documents/pro/ar/object_detection/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/kudos-it/Documents/pro/ar/object_detection/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/home/kudos-it/Documents/pro/ar/object_detection/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/home/kudos-it/Documents/pro/ar/object_detection/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/home/kudos-it/Documents/pro/ar/object_detection/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/kudos-it/Documents/pro/ar/object_detection/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/kudos-it/Documents/pro/ar/object_detection/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\nimport { backend_util, buffer, DataStorage, engine, env, kernel_impls, KernelBackend, max, slice_util, TensorBuffer, upcastType, util } from '@tensorflow/tfjs-core';\nvar nonMaxSuppressionV3Impl = kernel_impls.nonMaxSuppressionV3Impl;\nvar _split = kernel_impls.split;\nvar _tile = kernel_impls.tile;\nvar topkImpl = kernel_impls.topkImpl;\nvar whereImpl = kernel_impls.whereImpl;\nimport * as seedrandom from 'seedrandom';\nimport { assertNotComplex } from './cpu_util';\nimport { maxPoolPositions, pool } from './utils/pool_utils';\n\nfunction mapActivation(backend, x, activation, preluActivationWeights) {\n  if (activation === 'linear') {\n    return backend.linear(x);\n  } else if (activation === 'relu') {\n    return backend.relu(x);\n  } else if (activation === 'elu') {\n    return backend.elu(x);\n  } else if (activation === 'relu6') {\n    return backend.relu6(x);\n  } else if (activation === 'prelu') {\n    return backend.prelu(x, preluActivationWeights);\n  }\n\n  throw new Error(\"Activation \".concat(activation, \" has not been implemented for the CPU backend.\"));\n}\n\nexport var MathBackendCPU = /*#__PURE__*/function (_KernelBackend) {\n  _inherits(MathBackendCPU, _KernelBackend);\n\n  var _super = _createSuper(MathBackendCPU);\n\n  function MathBackendCPU() {\n    var _this;\n\n    _classCallCheck(this, MathBackendCPU);\n\n    _this = _super.call(this);\n    _this.blockSize = 48;\n    _this.firstUse = true;\n    _this.data = new DataStorage(_assertThisInitialized(_this), engine());\n    return _this;\n  }\n\n  _createClass(MathBackendCPU, [{\n    key: \"write\",\n    value: function write(values, shape, dtype) {\n      if (this.firstUse) {\n        this.firstUse = false;\n\n        if (env().get('IS_NODE')) {\n          backend_util.warn('\\n============================\\n' + 'Hi there ðŸ‘‹. Looks like you are running TensorFlow.js in ' + 'Node.js. To speed things up dramatically, install our node ' + 'backend, which binds to TensorFlow C++, by running ' + 'npm i @tensorflow/tfjs-node, ' + 'or npm i @tensorflow/tfjs-node-gpu if you have CUDA. ' + 'Then call require(\\'@tensorflow/tfjs-node\\'); (-gpu ' + 'suffix for CUDA) at the start of your program. ' + 'Visit https://github.com/tensorflow/tfjs-node for more details.' + '\\n============================');\n        }\n      }\n\n      var dataId = {};\n      this.data.set(dataId, {\n        values: values,\n        dtype: dtype,\n        refCount: 1\n      });\n      return dataId;\n    }\n    /** Increase refCount of a `TensorData`. */\n\n  }, {\n    key: \"incRef\",\n    value: function incRef(dataId) {\n      var tensorData = this.data.get(dataId);\n      tensorData.refCount++;\n    }\n    /** Decrease refCount of a `TensorData`. */\n\n  }, {\n    key: \"decRef\",\n    value: function decRef(dataId) {\n      if (this.data.has(dataId)) {\n        var tensorData = this.data.get(dataId);\n        tensorData.refCount--;\n      }\n    }\n  }, {\n    key: \"move\",\n    value: function move(dataId, values, shape, dtype) {\n      this.data.set(dataId, {\n        values: values,\n        dtype: dtype,\n        refCount: 1\n      });\n    }\n  }, {\n    key: \"numDataIds\",\n    value: function numDataIds() {\n      return this.data.numDataIds();\n    }\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(dataId) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", this.readSync(dataId));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function read(_x) {\n        return _read.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }, {\n    key: \"readSync\",\n    value: function readSync(dataId) {\n      var _this$data$get = this.data.get(dataId),\n          dtype = _this$data$get.dtype,\n          complexTensors = _this$data$get.complexTensors;\n\n      if (dtype === 'complex64') {\n        var realValues = this.readSync(complexTensors.real.dataId);\n        var imagValues = this.readSync(complexTensors.imag.dataId);\n        return backend_util.mergeRealAndImagArrays(realValues, imagValues);\n      }\n\n      return this.data.get(dataId).values;\n    }\n  }, {\n    key: \"bufferSync\",\n    value: function bufferSync(t) {\n      var data = this.readSync(t.dataId);\n      var decodedData = data;\n\n      if (t.dtype === 'string') {\n        try {\n          // Decode the bytes into string.\n          decodedData = data.map(function (d) {\n            return util.decodeString(d);\n          });\n        } catch (_a) {\n          throw new Error('Failed to decode encoded string bytes into utf-8');\n        }\n      }\n\n      return tf.buffer(t.shape, t.dtype, decodedData);\n    }\n  }, {\n    key: \"makeOutput\",\n    value: function makeOutput(values, shape, dtype) {\n      var dataId = this.write(values, shape, dtype);\n      return engine().makeTensorFromDataId(dataId, shape, dtype, this);\n    }\n  }, {\n    key: \"disposeData\",\n    value: function disposeData(dataId) {\n      if (this.data.has(dataId)) {\n        var _this$data$get2 = this.data.get(dataId),\n            complexTensors = _this$data$get2.complexTensors;\n\n        if (complexTensors != null) {\n          complexTensors.real.dispose();\n          complexTensors.imag.dispose();\n        }\n\n        this.data.delete(dataId);\n      }\n    }\n  }, {\n    key: \"disposeIntermediateTensorInfo\",\n    value: function disposeIntermediateTensorInfo(tensorInfo) {\n      var dataId = tensorInfo.dataId;\n\n      if (this.data.has(dataId)) {\n        var tensorData = this.data.get(dataId);\n        tensorData.refCount--;\n\n        if (tensorData.refCount < 1) {\n          this.disposeData(dataId);\n        }\n      }\n    }\n  }, {\n    key: \"time\",\n    value: function () {\n      var _time = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(f) {\n        var start, kernelMs;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                start = util.now();\n                f();\n                kernelMs = util.now() - start;\n                return _context2.abrupt(\"return\", {\n                  kernelMs: kernelMs\n                });\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function time(_x2) {\n        return _time.apply(this, arguments);\n      }\n\n      return time;\n    }()\n  }, {\n    key: \"memory\",\n    value: function memory() {\n      return {\n        // Unreliable due to automatic gc. The numbers above are cumulative.\n        unreliable: true,\n        reasons: ['The reported memory is an upper bound. Due to automatic garbage ' + 'collection, the true allocated memory may be less.']\n      };\n    }\n  }, {\n    key: \"complex\",\n    value: function complex(real, imag) {\n      var result = this.makeOutput(null, real.shape, 'complex64');\n      var resultData = this.data.get(result.dataId); // The backend owns the reference to the underlying real and imaginary\n      // clones. These will explicitly get disposed when the complex tensor is\n      // disposed.\n\n      resultData.complexTensors = {\n        real: engine().keep(real.clone()),\n        imag: engine().keep(imag.clone())\n      };\n      return result;\n    }\n  }, {\n    key: \"real\",\n    value: function real(input) {\n      var resultData = this.data.get(input.dataId);\n      return resultData.complexTensors.real.clone();\n    }\n  }, {\n    key: \"imag\",\n    value: function imag(input) {\n      var resultData = this.data.get(input.dataId);\n      return resultData.complexTensors.imag.clone();\n    }\n  }, {\n    key: \"slice\",\n    value: function slice(x, begin, size) {\n      assertNotComplex(x, 'slice');\n      var isContinous = slice_util.isSliceContinous(x.shape, begin, size);\n\n      if (isContinous) {\n        var flatOffset = slice_util.computeFlatOffset(begin, x.strides);\n        var length = util.sizeFromShape(size);\n        var vals = this.readSync(x.dataId);\n        return tf.tensor(vals.subarray(flatOffset, flatOffset + length), size, x.dtype);\n      }\n\n      var buffer = tf.buffer(size, x.dtype);\n      var xBuf = this.bufferSync(x);\n\n      for (var i = 0; i < buffer.size; ++i) {\n        var loc = buffer.indexToLoc(i);\n        var xLoc = loc.map(function (idx, j) {\n          return idx + begin[j];\n        });\n        buffer.values[i] = xBuf.get.apply(xBuf, _toConsumableArray(xLoc));\n      }\n\n      return buffer.toTensor();\n    }\n  }, {\n    key: \"stridedSlice\",\n    value: function stridedSlice(x, begin, end, strides) {\n      assertNotComplex(x, 'stridedSlice');\n      var outShape = slice_util.computeOutShape(begin, end, strides);\n\n      if (outShape.some(function (axis) {\n        return axis === 0;\n      })) {\n        return tf.tensor([], outShape);\n      }\n\n      var buffer = tf.buffer(outShape, x.dtype);\n      var xBuf = this.bufferSync(x);\n\n      for (var i = 0; i < buffer.size; i++) {\n        var loc = buffer.indexToLoc(i);\n        var newLoc = new Array(loc.length);\n\n        for (var j = 0; j < newLoc.length; j++) {\n          newLoc[j] = loc[j] * strides[j] + begin[j];\n        }\n\n        buffer.set.apply(buffer, [xBuf.get.apply(xBuf, newLoc)].concat(_toConsumableArray(loc)));\n      }\n\n      return buffer.toTensor();\n    }\n  }, {\n    key: \"diag\",\n    value: function diag(x) {\n      var xVals = this.readSync(x.dataId);\n      var buffer = tf.buffer([x.size, x.size], x.dtype);\n      var vals = buffer.values;\n\n      for (var i = 0; i < xVals.length; i++) {\n        vals[i * x.size + i] = xVals[i];\n      }\n\n      return buffer.toTensor();\n    }\n  }, {\n    key: \"unstack\",\n    value: function unstack(x, axis) {\n      var num = x.shape[axis];\n      var outShape = new Array(x.rank - 1);\n      var outIndex = 0;\n\n      for (var i = 0; i < x.rank; i++) {\n        if (i !== axis) {\n          outShape[outIndex++] = x.shape[i];\n        }\n      }\n\n      var begin = new Array(x.rank).fill(0);\n      var size = x.shape.slice();\n      size[axis] = 1;\n      var res = new Array(num);\n\n      for (var _i = 0; _i < res.length; _i++) {\n        begin[axis] = _i;\n        res[_i] = this.slice(x, begin, size).reshape(outShape);\n      }\n\n      return res;\n    }\n  }, {\n    key: \"reverse\",\n    value: function reverse(x, axis) {\n      assertNotComplex(x, 'reverse');\n      var buffer = tf.buffer(x.shape, x.dtype);\n      var xBuf = this.bufferSync(x);\n\n      var _loop = function _loop(i) {\n        var outLoc = buffer.indexToLoc(i);\n        var inLoc = outLoc.slice();\n        axis.forEach(function (ax) {\n          return inLoc[ax] = x.shape[ax] - 1 - inLoc[ax];\n        });\n        buffer.set.apply(buffer, [xBuf.get.apply(xBuf, _toConsumableArray(inLoc))].concat(_toConsumableArray(outLoc)));\n      };\n\n      for (var i = 0; i < buffer.size; i++) {\n        _loop(i);\n      }\n\n      return buffer.toTensor();\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(tensors, axis) {\n      var _this2 = this;\n\n      if (tensors[0].dtype === 'complex64') {\n        var reals = tensors.map(function (t) {\n          return tf.real(t);\n        });\n        var imags = tensors.map(function (t) {\n          return tf.imag(t);\n        });\n        return tf.complex(this.concat(reals, axis), this.concat(imags, axis));\n      }\n\n      var tensors2D = tensors.map(function (t) {\n        var innerSize = util.sizeFromShape(t.shape.slice(axis));\n        return t.as2D(-1, innerSize);\n      });\n      var outShape = backend_util.computeOutShape(tensors2D.map(function (t) {\n        return t.shape;\n      }), 1\n      /* axis\n      */\n      );\n      var values = tf.buffer(outShape, tensors[0].dtype).values;\n\n      if (tensors2D[0].shape[0] === 1) {\n        // Use built-in TypedArray.set() method for speed.\n        var offset = 0;\n        tensors2D.forEach(function (t) {\n          values.set(_this2.readSync(t.dataId), offset);\n          offset += t.size;\n        });\n      } else {\n        var colOffset = 0;\n        tensors2D.forEach(function (t) {\n          var tVals = _this2.readSync(t.dataId);\n\n          var tIdx = 0;\n\n          for (var row = 0; row < t.shape[0]; ++row) {\n            var resIdx = row * outShape[1] + colOffset;\n\n            for (var col = 0; col < t.shape[1]; ++col) {\n              values[resIdx + col] = tVals[tIdx++];\n            }\n          }\n\n          colOffset += t.shape[1];\n        });\n      }\n\n      var finalOutShape = backend_util.computeOutShape(tensors.map(function (t) {\n        return t.shape;\n      }), axis);\n      return tf.tensor(values, finalOutShape, tensors[0].dtype);\n    }\n  }, {\n    key: \"neg\",\n    value: function neg(x) {\n      assertNotComplex(x, 'neg');\n      return this.multiply(tf.scalar(-1), x);\n    }\n  }, {\n    key: \"add\",\n    value: function add(a, b) {\n      if (a.dtype === 'complex64' || b.dtype === 'complex64') {\n        return this.broadcastedBinaryComplexOp(a.cast('complex64'), b.cast('complex64'), function (aReal, aImag, bReal, bImag) {\n          return {\n            real: aReal + bReal,\n            imag: aImag + bImag\n          };\n        });\n      }\n\n      return this.broadcastedBinaryOp(a, b, upcastType(a.dtype, b.dtype), function (aValue, bValue) {\n        return aValue + bValue;\n      });\n    }\n  }, {\n    key: \"addN\",\n    value: function addN(tensors) {\n      var _this3 = this;\n\n      assertNotComplex(tensors, 'addN');\n      var vals = tensors.map(function (t) {\n        return _this3.readSync(t.dataId);\n      });\n      var result = tf.buffer(tensors[0].shape, tensors[0].dtype);\n      var resultVals = result.values;\n\n      for (var i = 0; i < tensors.length; i++) {\n        var currVals = vals[i];\n\n        for (var j = 0; j < resultVals.length; j++) {\n          resultVals[j] += currVals[j];\n        }\n      }\n\n      return result.toTensor();\n    }\n  }, {\n    key: \"softmax\",\n    value: function softmax(logits, dim) {\n      var axes = util.parseAxisParam([dim], logits.shape); // TODO(annxingyuan): Call maxImpl rather than op as part of softmax kernel\n      // modularization.\n\n      var maxLogit = max(logits, axes);\n      var expandedShape = backend_util.expandShapeToKeepDim(maxLogit.shape, axes);\n      var a = this.subtract(logits, maxLogit.reshape(expandedShape));\n      var b = this.exp(a);\n      var sumExp = this.sum(b, axes).reshape(expandedShape); // TODO(annxingyuan): Call divImpl rather than op as part of softmax\n      // kernel modularization.\n\n      return tf.div(b, sumExp);\n    }\n  }, {\n    key: \"subtract\",\n    value: function subtract(a, b) {\n      if (a.dtype === 'complex64' || b.dtype === 'complex64') {\n        return this.broadcastedBinaryComplexOp(a.cast('complex64'), b.cast('complex64'), function (aReal, aImag, bReal, bImag) {\n          return {\n            real: aReal - bReal,\n            imag: aImag - bImag\n          };\n        });\n      }\n\n      return this.broadcastedBinaryOp(a, b, upcastType(a.dtype, b.dtype), function (aValue, bValue) {\n        return aValue - bValue;\n      });\n    }\n  }, {\n    key: \"pow\",\n    value: function pow(a, b) {\n      assertNotComplex([a, b], 'pow');\n      return this.broadcastedBinaryOp(a, b, a.dtype, function (aValue, bValue) {\n        return Math.pow(aValue, bValue);\n      });\n    }\n  }, {\n    key: \"batchMatMul\",\n    value: function batchMatMul(a, b, transposeA, transposeB) {\n      assertNotComplex([a, b], 'matMul');\n      var sharedDim = transposeA ? a.shape[1] : a.shape[2];\n      var leftDim = transposeA ? a.shape[2] : a.shape[1];\n      var rightDim = transposeB ? b.shape[1] : b.shape[2];\n      var batchDim = a.shape[0];\n      var aValues = this.readSync(a.dataId);\n      var bValues = this.readSync(b.dataId);\n\n      var _ref = transposeA ? [a.strides[0], 1, a.strides[1]] : [a.strides[0], a.strides[1], 1],\n          _ref2 = _slicedToArray(_ref, 3),\n          aBatch = _ref2[0],\n          aOuterStep = _ref2[1],\n          aInnerStep = _ref2[2];\n\n      var _ref3 = transposeB ? [1, b.strides[1], b.strides[0]] : [b.strides[1], 1, b.strides[0]],\n          _ref4 = _slicedToArray(_ref3, 3),\n          bInnerStep = _ref4[0],\n          bOuterStep = _ref4[1],\n          bBatch = _ref4[2];\n\n      var size = leftDim * rightDim;\n      var result = tf.buffer([batchDim, leftDim, rightDim], a.dtype);\n      var resVals = result.values;\n      var blockSize = this.blockSize;\n\n      for (var _b = 0; _b < batchDim; _b++) {\n        for (var i0 = 0; i0 < leftDim; i0 += blockSize) {\n          for (var j0 = 0; j0 < rightDim; j0 += blockSize) {\n            for (var k0 = 0; k0 < sharedDim; k0 += blockSize) {\n              // for when blockSize doesn't evenly divide the input\n              var iBlock = Math.min(i0 + blockSize, leftDim);\n              var jBlock = Math.min(j0 + blockSize, rightDim);\n              var kBlock = Math.min(k0 + blockSize, sharedDim);\n\n              for (var i = i0; i < iBlock; i++) {\n                for (var j = j0; j < jBlock; j++) {\n                  var sum = 0.0;\n\n                  for (var k = k0; k < kBlock; k++) {\n                    sum += aValues[_b * aBatch + i * aOuterStep + k * aInnerStep] * bValues[k * bInnerStep + j * bOuterStep + _b * bBatch];\n                  }\n\n                  resVals[_b * size + (i * rightDim + j)] += sum;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return result.toTensor();\n    }\n  }, {\n    key: \"fusedBatchMatMul\",\n    value: function fusedBatchMatMul(_ref5) {\n      var a = _ref5.a,\n          b = _ref5.b,\n          transposeA = _ref5.transposeA,\n          transposeB = _ref5.transposeB,\n          bias = _ref5.bias,\n          activation = _ref5.activation,\n          preluActivationWeights = _ref5.preluActivationWeights;\n      var result = this.batchMatMul(a, b, transposeA, transposeB);\n\n      if (bias) {\n        result = this.add(result, bias);\n      }\n\n      if (activation) {\n        result = mapActivation(this, result, activation, preluActivationWeights);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply(a, b) {\n      if (a.dtype === 'complex64' || b.dtype === 'complex64') {\n        return this.broadcastedBinaryComplexOp(a.cast('complex64'), b.cast('complex64'), function (aReal, aImag, bReal, bImag) {\n          return {\n            real: aReal * bReal - aImag * bImag,\n            imag: aReal * bImag + aImag * bReal\n          };\n        });\n      }\n\n      return this.broadcastedBinaryOp(a, b, upcastType(a.dtype, b.dtype), function (aValue, bValue) {\n        return aValue * bValue;\n      });\n    }\n  }, {\n    key: \"floorDiv\",\n    value: function floorDiv(a, b) {\n      assertNotComplex([a, b], 'floorDiv');\n\n      var op = function op(a, b) {\n        return Math.floor(a / b);\n      };\n\n      var outputDtype = 'int32';\n      return this.broadcastedBinaryOp(a, b, outputDtype, op);\n    }\n  }, {\n    key: \"sum\",\n    value: function sum(x, axes) {\n      assertNotComplex(x, 'sum');\n      backend_util.assertAxesAreInnerMostDims('sum', axes, x.rank);\n\n      var _backend_util$compute = backend_util.computeOutAndReduceShapes(x.shape, axes),\n          _backend_util$compute2 = _slicedToArray(_backend_util$compute, 2),\n          outShape = _backend_util$compute2[0],\n          reduceShape = _backend_util$compute2[1];\n\n      var resultDtype = upcastType(x.dtype, 'int32');\n      var result = tf.zeros(outShape, resultDtype);\n      var reduceSize = util.sizeFromShape(reduceShape);\n      var vals = this.readSync(result.dataId);\n      var aVals = this.readSync(x.dataId);\n\n      for (var i = 0; i < vals.length; ++i) {\n        var offset = i * reduceSize;\n        var sum = 0;\n\n        for (var j = 0; j < reduceSize; ++j) {\n          sum += aVals[offset + j];\n        }\n\n        vals[i] = sum;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"prod\",\n    value: function prod(x, axes) {\n      assertNotComplex(x, 'sum');\n\n      var _backend_util$compute3 = backend_util.computeOutAndReduceShapes(x.shape, axes),\n          _backend_util$compute4 = _slicedToArray(_backend_util$compute3, 2),\n          outShape = _backend_util$compute4[0],\n          reduceShape = _backend_util$compute4[1];\n\n      var resultDtype = upcastType(x.dtype, 'int32');\n      var result = tf.zeros(outShape, resultDtype);\n      var reduceSize = util.sizeFromShape(reduceShape);\n      var vals = this.readSync(result.dataId);\n      var aVals = this.readSync(x.dataId);\n\n      for (var i = 0; i < vals.length; ++i) {\n        var offset = i * reduceSize;\n        var prod = 1;\n\n        for (var j = 0; j < reduceSize; ++j) {\n          prod *= aVals[offset + j];\n        }\n\n        vals[i] = prod;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"unsortedSegmentSum\",\n    value: function unsortedSegmentSum(x, segmentIds, numSegments) {\n      assertNotComplex(x, 'unsortedSegmentSum');\n      var res = []; // Reshape the segment id's so that they can be broadcast with\n      // x. The new shape should be [segmentIds.shape, 1, ..., 1]\n\n      var numIters = x.rank - segmentIds.rank;\n\n      for (var i = 0; i < numIters; ++i) {\n        segmentIds = segmentIds.expandDims(i + 1);\n      }\n\n      for (var _i2 = 0; _i2 < numSegments; ++_i2) {\n        var segmentId = tf.scalar(_i2, 'int32');\n        var mask = tf.equal(segmentId, segmentIds).asType('float32');\n        var sum = mask.mul(x).sum(0);\n        res.push(sum);\n      }\n\n      return tf.stack(res);\n    }\n  }, {\n    key: \"argMin\",\n    value: function argMin(x, axis) {\n      assertNotComplex(x, 'argMin');\n      var axes = [axis];\n      backend_util.assertAxesAreInnerMostDims('argMin', axes, x.rank);\n\n      var _backend_util$compute5 = backend_util.computeOutAndReduceShapes(x.shape, axes),\n          _backend_util$compute6 = _slicedToArray(_backend_util$compute5, 2),\n          outShape = _backend_util$compute6[0],\n          reduceShape = _backend_util$compute6[1];\n\n      var result = tf.zeros(outShape, 'int32');\n      var reduceSize = util.sizeFromShape(reduceShape);\n      var vals = this.readSync(result.dataId);\n      var aVals = this.readSync(x.dataId);\n\n      for (var i = 0; i < vals.length; ++i) {\n        var offset = i * reduceSize;\n        var min = aVals[offset];\n        var minIndex = 0;\n\n        for (var j = 0; j < reduceSize; ++j) {\n          var value = aVals[offset + j];\n\n          if (value < min) {\n            min = value;\n            minIndex = j;\n          }\n        }\n\n        vals[i] = minIndex;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"argMax\",\n    value: function argMax(x, axis) {\n      assertNotComplex(x, 'argMax');\n      var axes = [axis];\n      backend_util.assertAxesAreInnerMostDims('argMax', axes, x.rank);\n\n      var _backend_util$compute7 = backend_util.computeOutAndReduceShapes(x.shape, axes),\n          _backend_util$compute8 = _slicedToArray(_backend_util$compute7, 2),\n          outShape = _backend_util$compute8[0],\n          reduceShape = _backend_util$compute8[1];\n\n      var result = tf.zeros(outShape, 'int32');\n      var reduceSize = util.sizeFromShape(reduceShape);\n      var vals = this.readSync(result.dataId);\n      var aVals = this.readSync(x.dataId);\n\n      for (var i = 0; i < vals.length; ++i) {\n        var offset = i * reduceSize;\n        var _max = aVals[offset];\n        var maxIndex = 0;\n\n        for (var j = 0; j < reduceSize; ++j) {\n          var value = aVals[offset + j];\n\n          if (value > _max) {\n            _max = value;\n            maxIndex = j;\n          }\n        }\n\n        vals[i] = maxIndex;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"cumsum\",\n    value: function cumsum(x, axis, exclusive, reverse) {\n      assertNotComplex(x, 'cumsum');\n\n      if (axis !== x.rank - 1) {\n        throw new Error(\"backend.cumsum in CPU expects an inner-most axis=\".concat(x.rank - 1, \" \") + \"but got axis=\".concat(axis));\n      }\n\n      var resultDtype = upcastType(x.dtype, 'int32');\n      var result = tf.zeros(x.shape, resultDtype);\n      var vals = this.readSync(result.dataId);\n      var aVals = this.readSync(x.dataId);\n      var finalDim = x.shape[x.rank - 1];\n      var indexAdjuster = reverse ? function (i, j) {\n        return i + finalDim - j - 1;\n      } : function (i, j) {\n        return i + j;\n      };\n\n      for (var i = 0; i < aVals.length; i += finalDim) {\n        for (var j = 0; j < finalDim; j++) {\n          var idx = indexAdjuster(i, j);\n\n          if (j === 0) {\n            vals[idx] = exclusive ? 0 : aVals[idx];\n          } else {\n            var prevIdx = indexAdjuster(i, j - 1);\n            vals[idx] = exclusive ? aVals[prevIdx] + vals[prevIdx] : aVals[idx] + vals[prevIdx];\n          }\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"equal\",\n    value: function equal(a, b) {\n      assertNotComplex([a, b], 'equal');\n      return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {\n        return aVal === bVal ? 1 : 0;\n      });\n    }\n  }, {\n    key: \"notEqual\",\n    value: function notEqual(a, b) {\n      assertNotComplex([a, b], 'notEqual');\n      return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {\n        return aVal !== bVal ? 1 : 0;\n      });\n    }\n  }, {\n    key: \"less\",\n    value: function less(a, b) {\n      assertNotComplex([a, b], 'less');\n      return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {\n        return aVal < bVal ? 1 : 0;\n      });\n    }\n  }, {\n    key: \"lessEqual\",\n    value: function lessEqual(a, b) {\n      assertNotComplex([a, b], 'lessEqual');\n      return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {\n        return aVal <= bVal ? 1 : 0;\n      });\n    }\n  }, {\n    key: \"greater\",\n    value: function greater(a, b) {\n      assertNotComplex([a, b], 'greater');\n      return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {\n        return aVal > bVal ? 1 : 0;\n      });\n    }\n  }, {\n    key: \"greaterEqual\",\n    value: function greaterEqual(a, b) {\n      assertNotComplex([a, b], 'greaterEqual');\n      return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {\n        return aVal >= bVal ? 1 : 0;\n      });\n    }\n  }, {\n    key: \"logicalNot\",\n    value: function logicalNot(x) {\n      assertNotComplex(x, 'logicalNot');\n      var values = this.readSync(x.dataId);\n      var newValues = new Uint8Array(values.length);\n\n      for (var i = 0; i < values.length; ++i) {\n        newValues[i] = values[i] ? 0 : 1;\n      }\n\n      return this.makeOutput(newValues, x.shape, 'bool');\n    }\n  }, {\n    key: \"logicalAnd\",\n    value: function logicalAnd(a, b) {\n      assertNotComplex([a, b], 'logicalAnd');\n      return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {\n        return aVal && bVal;\n      });\n    }\n  }, {\n    key: \"logicalOr\",\n    value: function logicalOr(a, b) {\n      assertNotComplex([a, b], 'logicalOr');\n      return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {\n        return aVal || bVal;\n      });\n    }\n  }, {\n    key: \"select\",\n    value: function select(condition, a, b) {\n      assertNotComplex([condition, a, b], 'select');\n      var values = this.readSync(condition.dataId);\n      var aValues = this.readSync(a.dataId);\n      var bValues = this.readSync(b.dataId);\n      var result = tf.zeros(a.shape, upcastType(a.dtype, b.dtype));\n      var newValues = this.readSync(result.dataId);\n      var index = 0;\n      var offset = condition.rank === 0 || condition.rank > 1 || a.rank === 1 ? 1 : util.sizeFromShape(a.shape.slice(1));\n\n      for (var i = 0; i < values.length; i++) {\n        for (var j = 0; j < offset; j++) {\n          if (values[i] === 1) {\n            newValues[index++] = aValues[i];\n          } else {\n            newValues[index++] = bValues[i];\n          }\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"where\",\n    value: function where(condition) {\n      assertNotComplex([condition], 'where');\n      var condVals = this.readSync(condition.dataId);\n      return whereImpl(condition.shape, condVals);\n    }\n  }, {\n    key: \"topk\",\n    value: function topk(x, k, sorted) {\n      assertNotComplex(x, 'topk');\n      var xVals = this.readSync(x.dataId);\n      return topkImpl(xVals, x.shape, x.dtype, k, sorted);\n    }\n  }, {\n    key: \"min\",\n    value: function min(x, axes) {\n      assertNotComplex(x, 'min');\n      backend_util.assertAxesAreInnerMostDims('min', axes, x.rank);\n\n      var _backend_util$compute9 = backend_util.computeOutAndReduceShapes(x.shape, axes),\n          _backend_util$compute10 = _slicedToArray(_backend_util$compute9, 2),\n          outShape = _backend_util$compute10[0],\n          reduceShape = _backend_util$compute10[1];\n\n      var result = tf.zeros(outShape, x.dtype);\n      var reduceSize = util.sizeFromShape(reduceShape);\n      var vals = this.readSync(result.dataId);\n      var aVals = this.readSync(x.dataId);\n\n      for (var i = 0; i < vals.length; ++i) {\n        var offset = i * reduceSize;\n        var min = aVals[offset];\n\n        for (var j = 0; j < reduceSize; ++j) {\n          var value = aVals[offset + j];\n\n          if (value < min) {\n            min = value;\n          }\n        }\n\n        vals[i] = min;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"minimum\",\n    value: function minimum(a, b) {\n      assertNotComplex([a, b], 'minimum');\n      return this.broadcastedBinaryOp(a, b, a.dtype, function (aVal, bVal) {\n        return Math.min(aVal, bVal);\n      });\n    }\n  }, {\n    key: \"mod\",\n    value: function mod(a, b) {\n      assertNotComplex([a, b], 'mod');\n      return this.broadcastedBinaryOp(a, b, a.dtype, function (aVal, bVal) {\n        var rem = aVal % bVal;\n\n        if (aVal < 0 && bVal < 0 || aVal >= 0 && bVal >= 0) {\n          return rem;\n        } else {\n          return (rem + bVal) % bVal;\n        }\n      });\n    }\n  }, {\n    key: \"maximum\",\n    value: function maximum(a, b) {\n      assertNotComplex([a, b], 'maximum');\n      return this.broadcastedBinaryOp(a, b, a.dtype, function (aVal, bVal) {\n        return Math.max(aVal, bVal);\n      });\n    }\n  }, {\n    key: \"all\",\n    value: function all(x, axes) {\n      assertNotComplex(x, 'all');\n      backend_util.assertAxesAreInnerMostDims('all', axes, x.rank);\n\n      var _backend_util$compute11 = backend_util.computeOutAndReduceShapes(x.shape, axes),\n          _backend_util$compute12 = _slicedToArray(_backend_util$compute11, 2),\n          outShape = _backend_util$compute12[0],\n          reduceShape = _backend_util$compute12[1];\n\n      var result = tf.zeros(outShape, x.dtype);\n      var reduceSize = util.sizeFromShape(reduceShape);\n      var vals = this.readSync(result.dataId);\n      var aVals = this.readSync(x.dataId);\n\n      for (var i = 0; i < vals.length; ++i) {\n        var offset = i * reduceSize;\n        var all = aVals[offset];\n\n        for (var j = 0; j < reduceSize; ++j) {\n          var value = aVals[offset + j];\n          all = all && value;\n        }\n\n        vals[i] = all;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"any\",\n    value: function any(x, axes) {\n      assertNotComplex(x, 'any');\n      backend_util.assertAxesAreInnerMostDims('any', axes, x.rank);\n\n      var _backend_util$compute13 = backend_util.computeOutAndReduceShapes(x.shape, axes),\n          _backend_util$compute14 = _slicedToArray(_backend_util$compute13, 2),\n          outShape = _backend_util$compute14[0],\n          reduceShape = _backend_util$compute14[1];\n\n      var result = tf.zeros(outShape, x.dtype);\n      var reduceSize = util.sizeFromShape(reduceShape);\n      var vals = this.readSync(result.dataId);\n      var aVals = this.readSync(x.dataId);\n\n      for (var i = 0; i < vals.length; ++i) {\n        var offset = i * reduceSize;\n        var anyVal = aVals[offset];\n\n        for (var j = 0; j < reduceSize; ++j) {\n          var value = aVals[offset + j];\n          anyVal = anyVal || value;\n        }\n\n        vals[i] = anyVal;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"squaredDifference\",\n    value: function squaredDifference(a, b) {\n      assertNotComplex([a, b], 'squaredDifference');\n      return this.broadcastedBinaryOp(a, b, a.dtype, function (aVal, bVal) {\n        var diff = aVal - bVal;\n        return diff * diff;\n      });\n    }\n  }, {\n    key: \"ceil\",\n    value: function ceil(x) {\n      assertNotComplex(x, 'ceil');\n      var values = this.readSync(x.dataId);\n      var newValues = new Float32Array(values.length);\n\n      for (var i = 0; i < values.length; ++i) {\n        newValues[i] = Math.ceil(values[i]);\n      }\n\n      return this.makeOutput(newValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"floor\",\n    value: function floor(x) {\n      assertNotComplex(x, 'floor');\n      var values = this.readSync(x.dataId);\n      var newValues = new Float32Array(values.length);\n\n      for (var i = 0; i < values.length; ++i) {\n        newValues[i] = Math.floor(values[i]);\n      }\n\n      return this.makeOutput(newValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"sign\",\n    value: function sign(x) {\n      assertNotComplex(x, 'x');\n      var values = this.readSync(x.dataId);\n      var newValues = new Float32Array(values.length);\n\n      for (var i = 0; i < values.length; ++i) {\n        if (values[i] < 0) {\n          newValues[i] = -1;\n        } else if (values[i] > 0) {\n          newValues[i] = 1;\n        } else {\n          newValues[i] = 0;\n        }\n      }\n\n      return this.makeOutput(newValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"isNaN\",\n    value: function isNaN(x) {\n      assertNotComplex(x, 'x');\n      var values = this.readSync(x.dataId);\n      var newValues = new Uint8Array(values.length);\n\n      for (var i = 0; i < values.length; ++i) {\n        if (Number.isNaN(values[i])) {\n          newValues[i] = 1;\n        }\n      }\n\n      return this.makeOutput(newValues, x.shape, 'bool');\n    }\n  }, {\n    key: \"isInf\",\n    value: function isInf(x) {\n      assertNotComplex(x, 'x');\n      var values = this.readSync(x.dataId);\n      var newValues = new Uint8Array(values.length);\n\n      for (var i = 0; i < values.length; ++i) {\n        if (Math.abs(values[i]) === Infinity) {\n          newValues[i] = 1;\n        }\n      }\n\n      return this.makeOutput(newValues, x.shape, 'bool');\n    }\n  }, {\n    key: \"isFinite\",\n    value: function isFinite(x) {\n      assertNotComplex(x, 'x');\n      var values = this.readSync(x.dataId);\n      var newValues = new Uint8Array(values.length);\n\n      for (var i = 0; i < values.length; ++i) {\n        if (Number.isFinite(values[i])) {\n          newValues[i] = 1;\n        }\n      }\n\n      return this.makeOutput(newValues, x.shape, 'bool');\n    }\n  }, {\n    key: \"round\",\n    value: function round(x) {\n      assertNotComplex(x, 'round');\n      var values = this.readSync(x.dataId);\n      var newValues = new Float32Array(values.length);\n\n      for (var i = 0; i < values.length; ++i) {\n        // The algorithm is based on banker's rounding.\n        var base = Math.floor(values[i]);\n\n        if (values[i] - base < 0.5) {\n          newValues[i] = Math.floor(values[i]);\n        } else if (values[i] - base > 0.5) {\n          newValues[i] = Math.ceil(values[i]);\n        } else {\n          if (base % 2.0 === 0.0) {\n            newValues[i] = base;\n          } else {\n            newValues[i] = base + 1.0;\n          }\n        }\n      }\n\n      return this.makeOutput(newValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"exp\",\n    value: function exp(x) {\n      assertNotComplex(x, 'exp');\n      var values = this.readSync(x.dataId);\n      var newValues = new Float32Array(values.length);\n\n      for (var i = 0; i < values.length; ++i) {\n        newValues[i] = Math.exp(values[i]);\n      }\n\n      return this.makeOutput(newValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"expm1\",\n    value: function expm1(x) {\n      assertNotComplex(x, 'expm1');\n      var values = this.readSync(x.dataId);\n      var newValues = new Float32Array(values.length);\n\n      for (var i = 0; i < values.length; ++i) {\n        newValues[i] = Math.expm1(values[i]);\n      }\n\n      return this.makeOutput(newValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"log\",\n    value: function log(x) {\n      assertNotComplex(x, 'log');\n      var values = this.readSync(x.dataId);\n      var newValues = new Float32Array(values.length);\n\n      for (var i = 0; i < values.length; ++i) {\n        var value = values[i];\n        newValues[i] = Math.log(value);\n      }\n\n      return this.makeOutput(newValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"log1p\",\n    value: function log1p(x) {\n      assertNotComplex(x, 'log1p');\n      var values = this.readSync(x.dataId);\n      var newValues = new Float32Array(values.length);\n\n      for (var i = 0; i < values.length; ++i) {\n        var value = values[i];\n        newValues[i] = Math.log1p(value);\n      }\n\n      return this.makeOutput(newValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"sqrt\",\n    value: function sqrt(x) {\n      assertNotComplex(x, 'sqrt');\n      var values = this.readSync(x.dataId);\n      var newValues = new Float32Array(values.length);\n\n      for (var i = 0; i < values.length; ++i) {\n        var value = values[i];\n        newValues[i] = Math.sqrt(value);\n      }\n\n      return this.makeOutput(newValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"rsqrt\",\n    value: function rsqrt(x) {\n      assertNotComplex(x, 'rsqrt');\n      var values = this.readSync(x.dataId);\n      var newValues = new Float32Array(values.length);\n\n      for (var i = 0; i < values.length; ++i) {\n        var value = values[i];\n        newValues[i] = 1 / Math.sqrt(value);\n      }\n\n      return this.makeOutput(newValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"reciprocal\",\n    value: function reciprocal(x) {\n      assertNotComplex(x, 'reciprocal');\n      var values = this.readSync(x.dataId);\n      var newValues = new Float32Array(values.length);\n\n      for (var i = 0; i < values.length; ++i) {\n        newValues[i] = 1 / values[i];\n      }\n\n      return this.makeOutput(newValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"linear\",\n    value: function linear(x) {\n      return x;\n    }\n  }, {\n    key: \"relu\",\n    value: function relu(x) {\n      assertNotComplex(x, 'relu');\n      var res = tf.zeros(x.shape, x.dtype);\n      var resVals = this.readSync(res.dataId);\n      var inVals = this.readSync(x.dataId);\n\n      for (var i = 0; i < inVals.length; ++i) {\n        resVals[i] = Math.max(0, inVals[i]);\n      }\n\n      return res;\n    }\n  }, {\n    key: \"relu6\",\n    value: function relu6(x) {\n      assertNotComplex(x, 'relu');\n      var res = tf.zeros(x.shape, x.dtype);\n      var resVals = this.readSync(res.dataId);\n      var inVals = this.readSync(x.dataId);\n\n      for (var i = 0; i < inVals.length; ++i) {\n        resVals[i] = Math.min(Math.max(0, inVals[i]), 6);\n      }\n\n      return res;\n    }\n  }, {\n    key: \"prelu\",\n    value: function prelu(x, a) {\n      assertNotComplex([x, a], 'prelu');\n      return this.broadcastedBinaryOp(x, a, x.dtype, function (xValue, aValue) {\n        return xValue < 0 ? aValue * xValue : xValue;\n      });\n    }\n  }, {\n    key: \"elu\",\n    value: function elu(x) {\n      assertNotComplex(x, 'elu');\n      var resultValues = new Float32Array(x.size);\n      var values = this.readSync(x.dataId);\n\n      for (var i = 0; i < values.length; ++i) {\n        var v = values[i];\n\n        if (v >= 0) {\n          resultValues[i] = v;\n        } else {\n          resultValues[i] = Math.exp(v) - 1;\n        }\n      }\n\n      return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"eluDer\",\n    value: function eluDer(dy, y) {\n      assertNotComplex([dy, y], 'eluDer');\n      var resultValues = new Float32Array(y.size);\n      var values = this.readSync(y.dataId);\n      var dyValues = this.readSync(dy.dataId);\n\n      for (var i = 0; i < values.length; ++i) {\n        var v = values[i];\n\n        if (v >= 1) {\n          resultValues[i] = dyValues[i];\n        } else {\n          resultValues[i] = dyValues[i] * (v + 1);\n        }\n      }\n\n      return this.makeOutput(resultValues, y.shape, 'float32');\n    }\n  }, {\n    key: \"selu\",\n    value: function selu(x) {\n      assertNotComplex(x, 'selu'); // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n      // see: https://arxiv.org/abs/1706.02515\n\n      var scaleAlpha = backend_util.SELU_SCALEALPHA;\n      var scale = backend_util.SELU_SCALE;\n      var resultValues = new Float32Array(x.size);\n      var values = this.readSync(x.dataId);\n\n      for (var i = 0; i < values.length; ++i) {\n        var v = values[i];\n\n        if (v >= 0) {\n          resultValues[i] = scale * v;\n        } else {\n          resultValues[i] = scaleAlpha * (Math.exp(v) - 1);\n        }\n      }\n\n      return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"clip\",\n    value: function clip(x, min, max) {\n      assertNotComplex(x, 'clip');\n      var resultValues = new Float32Array(x.size);\n      var values = this.readSync(x.dataId);\n\n      for (var i = 0; i < values.length; ++i) {\n        var v = values[i];\n        resultValues[i] = v > max ? max : v < min ? min : v;\n      }\n\n      return this.makeOutput(resultValues, x.shape, x.dtype);\n    }\n  }, {\n    key: \"abs\",\n    value: function abs(x) {\n      var resultValues = new Float32Array(x.size);\n      var values = this.readSync(x.dataId);\n\n      for (var i = 0; i < values.length; ++i) {\n        resultValues[i] = Math.abs(values[i]);\n      }\n\n      return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"complexAbs\",\n    value: function complexAbs(x) {\n      var resultValues = new Float32Array(x.size);\n      var values = this.readSync(x.dataId);\n\n      for (var i = 0; i < x.size; ++i) {\n        var real = values[i * 2];\n        var imag = values[i * 2 + 1];\n        resultValues[i] = Math.hypot(real, imag);\n      }\n\n      return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"int\",\n    value: function int(x) {\n      assertNotComplex(x, 'int');\n      var resultValues = new Int32Array(x.size);\n      var values = this.readSync(x.dataId);\n\n      for (var i = 0; i < values.length; ++i) {\n        resultValues[i] = values[i];\n      }\n\n      return this.makeOutput(resultValues, x.shape, 'int32');\n    }\n  }, {\n    key: \"sigmoid\",\n    value: function sigmoid(x) {\n      assertNotComplex(x, 'sigmoid');\n      var resultValues = new Float32Array(x.size);\n      var values = this.readSync(x.dataId);\n\n      for (var i = 0; i < values.length; ++i) {\n        resultValues[i] = 1 / (1 + Math.exp(-values[i]));\n      }\n\n      return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"softplus\",\n    value: function softplus(x) {\n      assertNotComplex(x, 'softplus'); // mirrors the implementation of tf.nn.softplus: https://goo.gl/vkcvwX\n      // epsilon is the difference between 1.0 and the next representable float.\n      // For a single precision 32 bit float this should be 2^-23, see:\n      // https://math.byu.edu/~schow/work/IEEEFloatingPoint.htm\n\n      var epsilon = 1.1920928955078125e-7;\n      var threshold = Math.log(epsilon) + 2.0;\n      var resultValues = new Float32Array(x.size);\n      var values = this.readSync(x.dataId);\n\n      for (var i = 0; i < values.length; ++i) {\n        // Value above which exp(x) may overflow, but softplus(x) == x\n        // is within machine epsilon.\n        var tooLarge = values[i] > -threshold; // Value below which exp(x) may underflow, but softplus(x) == exp(x)\n        // is within machine epsilon.\n\n        var tooSmall = values[i] < threshold;\n        var expX = Math.exp(values[i]);\n        var result = void 0;\n\n        if (tooSmall) {\n          result = expX;\n        } else if (tooLarge) {\n          result = values[i];\n        } else {\n          result = Math.log(1.0 + expX);\n        }\n\n        resultValues[i] = result;\n      }\n\n      return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"sin\",\n    value: function sin(x) {\n      assertNotComplex(x, 'sin');\n      var resultValues = new Float32Array(x.size);\n      var values = this.readSync(x.dataId);\n\n      for (var i = 0; i < values.length; ++i) {\n        resultValues[i] = Math.sin(values[i]);\n      }\n\n      return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"tan\",\n    value: function tan(x) {\n      assertNotComplex(x, 'tan');\n      var resultValues = new Float32Array(x.size);\n      var values = this.readSync(x.dataId);\n\n      for (var i = 0; i < values.length; ++i) {\n        resultValues[i] = Math.tan(values[i]);\n      }\n\n      return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"asin\",\n    value: function asin(x) {\n      assertNotComplex(x, 'asin');\n      var resultValues = new Float32Array(x.size);\n      var values = this.readSync(x.dataId);\n\n      for (var i = 0; i < values.length; ++i) {\n        resultValues[i] = Math.asin(values[i]);\n      }\n\n      return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"acos\",\n    value: function acos(x) {\n      assertNotComplex(x, 'acos');\n      var resultValues = new Float32Array(x.size);\n      var values = this.readSync(x.dataId);\n\n      for (var i = 0; i < values.length; ++i) {\n        resultValues[i] = Math.acos(values[i]);\n      }\n\n      return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"atan\",\n    value: function atan(x) {\n      assertNotComplex(x, 'atan');\n      var resultValues = new Float32Array(x.size);\n      var values = this.readSync(x.dataId);\n\n      for (var i = 0; i < values.length; ++i) {\n        resultValues[i] = Math.atan(values[i]);\n      }\n\n      return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"atan2\",\n    value: function atan2(a, b) {\n      assertNotComplex([a, b], 'atan2');\n      return this.broadcastedBinaryOp(a, b, a.dtype, function (aValue, bValue) {\n        return Math.atan2(aValue, bValue);\n      });\n    }\n  }, {\n    key: \"sinh\",\n    value: function sinh(x) {\n      assertNotComplex(x, 'sinh');\n      var resultValues = new Float32Array(x.size);\n      var values = this.readSync(x.dataId);\n\n      for (var i = 0; i < values.length; ++i) {\n        resultValues[i] = Math.sinh(values[i]);\n      }\n\n      return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"cosh\",\n    value: function cosh(x) {\n      assertNotComplex(x, 'cosh');\n      var resultValues = new Float32Array(x.size);\n      var values = this.readSync(x.dataId);\n\n      for (var i = 0; i < values.length; ++i) {\n        resultValues[i] = Math.cosh(values[i]);\n      }\n\n      return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"tanh\",\n    value: function tanh(x) {\n      assertNotComplex(x, 'tanh');\n      var resultValues = new Float32Array(x.size);\n      var values = this.readSync(x.dataId);\n\n      for (var i = 0; i < values.length; ++i) {\n        resultValues[i] = util.tanh(values[i]);\n      }\n\n      return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"asinh\",\n    value: function asinh(x) {\n      assertNotComplex(x, 'asinh');\n      var resultValues = new Float32Array(x.size);\n      var values = this.readSync(x.dataId);\n\n      for (var i = 0; i < values.length; ++i) {\n        resultValues[i] = Math.asinh(values[i]);\n      }\n\n      return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"acosh\",\n    value: function acosh(x) {\n      assertNotComplex(x, 'acosh');\n      var resultValues = new Float32Array(x.size);\n      var values = this.readSync(x.dataId);\n\n      for (var i = 0; i < values.length; ++i) {\n        resultValues[i] = Math.acosh(values[i]);\n      }\n\n      return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"atanh\",\n    value: function atanh(x) {\n      assertNotComplex(x, 'atanh');\n      var resultValues = new Float32Array(x.size);\n      var values = this.readSync(x.dataId);\n\n      for (var i = 0; i < values.length; ++i) {\n        resultValues[i] = Math.atanh(values[i]);\n      }\n\n      return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"erf\",\n    value: function erf(x) {\n      assertNotComplex(x, 'erf');\n      var resultValues = new Float32Array(x.size);\n      var values = this.readSync(x.dataId);\n      var p = backend_util.ERF_P;\n      var a1 = backend_util.ERF_A1;\n      var a2 = backend_util.ERF_A2;\n      var a3 = backend_util.ERF_A3;\n      var a4 = backend_util.ERF_A4;\n      var a5 = backend_util.ERF_A5;\n\n      for (var i = 0; i < values.length; ++i) {\n        var sign = Math.sign(values[i]);\n        var v = Math.abs(values[i]);\n        var t = 1.0 / (1.0 + p * v);\n        resultValues[i] = sign * (1.0 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-v * v));\n      }\n\n      return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"step\",\n    value: function step(x) {\n      var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      assertNotComplex(x, 'step');\n      var resultValues = new Float32Array(x.size);\n      var values = this.readSync(x.dataId);\n\n      for (var i = 0; i < values.length; ++i) {\n        var value = values[i];\n\n        if (isNaN(value)) {\n          resultValues[i] = NaN;\n        } else {\n          resultValues[i] = value > 0 ? 1 : alpha;\n        }\n      }\n\n      return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n  }, {\n    key: \"fusedConv2d\",\n    value: function fusedConv2d(_ref6) {\n      var input = _ref6.input,\n          filter = _ref6.filter,\n          convInfo = _ref6.convInfo,\n          bias = _ref6.bias,\n          activation = _ref6.activation,\n          preluActivationWeights = _ref6.preluActivationWeights;\n      var result = this.conv2d(input, filter, convInfo);\n\n      if (bias) {\n        result = this.add(result, bias);\n      }\n\n      if (activation) {\n        result = mapActivation(this, result, activation, preluActivationWeights);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"conv2d\",\n    value: function conv2d(x, filter, convInfo) {\n      assertNotComplex([x, filter], 'conv2d');\n      var filterHeight = convInfo.filterHeight;\n      var filterWidth = convInfo.filterWidth;\n      var dilationHeight = convInfo.dilationHeight;\n      var dilationWidth = convInfo.dilationWidth;\n      var padLeft = convInfo.padInfo.left;\n      var padTop = convInfo.padInfo.top;\n      var isChannelsLast = convInfo.dataFormat === 'channelsLast';\n      var y = tf.buffer(convInfo.outShape, x.dtype);\n      var xBatchStride = x.strides[0];\n      var xRowStride = isChannelsLast ? x.strides[1] : x.strides[2];\n      var xColStride = isChannelsLast ? x.strides[2] : 1;\n      var xChannelStride = isChannelsLast ? 1 : x.strides[1];\n      var yBatchStride = y.strides[0];\n      var yRowStride = isChannelsLast ? y.strides[1] : y.strides[2];\n      var yColStride = isChannelsLast ? y.strides[2] : 1;\n      var yChannelStride = isChannelsLast ? 1 : y.strides[1];\n      var xVals = this.readSync(x.dataId);\n      var wVals = this.readSync(filter.dataId);\n      var yVals = y.values;\n\n      for (var b = 0; b < convInfo.batchSize; ++b) {\n        var xOffset1 = b * xBatchStride;\n        var yOffset1 = b * yBatchStride;\n\n        for (var yR = 0; yR < convInfo.outHeight; ++yR) {\n          var yOffset2 = yOffset1 + yR * yRowStride;\n          var xRCorner = yR * convInfo.strideHeight - padTop;\n\n          for (var wR = 0; wR < filterHeight; wR++) {\n            var xR = xRCorner + wR * dilationHeight;\n\n            if (xR < 0 || xR >= convInfo.inHeight) {\n              continue;\n            }\n\n            var wOffset1 = wR * filter.strides[0];\n            var xOffset2 = xOffset1 + xR * xRowStride;\n\n            for (var yC = 0; yC < convInfo.outWidth; ++yC) {\n              var yOffset3 = yOffset2 + yC * yColStride;\n              var xCCorner = yC * convInfo.strideWidth - padLeft;\n\n              for (var wC = 0; wC < filterWidth; wC++) {\n                var xC = xCCorner + wC * dilationWidth;\n\n                if (xC < 0 || xC >= convInfo.inWidth) {\n                  continue;\n                }\n\n                var wOffset2 = wOffset1 + wC * filter.strides[1];\n                var xOffset3 = xOffset2 + xC * xColStride;\n                var wOffset3 = wOffset2;\n\n                for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {\n                  var xVal = xVals[xOffset3 + d1 * xChannelStride];\n\n                  for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {\n                    yVals[yOffset3 + d2 * yChannelStride] += xVal * wVals[wOffset3 + d2];\n                  }\n\n                  wOffset3 += convInfo.outChannels;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return y.toTensor();\n    }\n  }, {\n    key: \"conv3d\",\n    value: function conv3d(x, filter, convInfo) {\n      var filterDepth = convInfo.filterDepth;\n      var filterHeight = convInfo.filterHeight;\n      var filterWidth = convInfo.filterWidth;\n      var dilationDepth = convInfo.dilationDepth;\n      var dilationHeight = convInfo.dilationHeight;\n      var dilationWidth = convInfo.dilationWidth;\n      var padFront = convInfo.padInfo.front;\n      var padLeft = convInfo.padInfo.left;\n      var padTop = convInfo.padInfo.top;\n      var y = tf.buffer(convInfo.outShape, x.dtype);\n      var xVals = this.readSync(x.dataId);\n      var wVals = this.readSync(filter.dataId);\n      var yVals = y.values;\n\n      for (var b = 0; b < convInfo.batchSize; ++b) {\n        var xOffset1 = b * x.strides[0];\n        var yOffset1 = b * y.strides[0];\n\n        for (var yF = 0; yF < convInfo.outDepth; ++yF) {\n          var yOffset2 = yOffset1 + yF * y.strides[1];\n          var xFCorner = yF * convInfo.strideDepth - padFront;\n\n          for (var wF = 0; wF < filterDepth; wF++) {\n            var xF = xFCorner + wF * dilationDepth;\n\n            if (xF < 0 || xF >= convInfo.inDepth) {\n              continue;\n            }\n\n            var wOffset1 = wF * filter.strides[0];\n            var xOffset2 = xOffset1 + xF * x.strides[1];\n\n            for (var yR = 0; yR < convInfo.outHeight; ++yR) {\n              var yOffset3 = yOffset2 + yR * y.strides[2];\n              var xRCorner = yR * convInfo.strideHeight - padTop;\n\n              for (var wR = 0; wR < filterHeight; wR++) {\n                var xR = xRCorner + wR * dilationHeight;\n\n                if (xR < 0 || xR >= convInfo.inHeight) {\n                  continue;\n                }\n\n                var wOffset2 = wOffset1 + wR * filter.strides[1];\n                var xOffset3 = xOffset2 + xR * x.strides[2];\n\n                for (var yC = 0; yC < convInfo.outWidth; ++yC) {\n                  var yOffset4 = yOffset3 + yC * convInfo.outChannels;\n                  var xCCorner = yC * convInfo.strideWidth - padLeft;\n\n                  for (var wC = 0; wC < filterWidth; wC++) {\n                    var xC = xCCorner + wC * dilationWidth;\n\n                    if (xC < 0 || xC >= convInfo.inWidth) {\n                      continue;\n                    }\n\n                    var wOffset3 = wOffset2 + wC * filter.strides[2];\n                    var xOffset4 = xOffset3 + xC * convInfo.inChannels;\n                    var wOffset4 = wOffset3;\n\n                    for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {\n                      var xVal = xVals[xOffset4 + d1];\n\n                      for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {\n                        yVals[yOffset4 + d2] += xVal * wVals[wOffset4 + d2];\n                      }\n\n                      wOffset4 += convInfo.outChannels;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return y.toTensor();\n    }\n  }, {\n    key: \"conv2dDerInput\",\n    value: function conv2dDerInput(dy, filter, convInfo) {\n      assertNotComplex([dy, filter], 'conv2dDerInput');\n      var dx = tf.buffer(convInfo.inShape, 'float32');\n      var dxValues = dx.values;\n      var dyValues = this.readSync(dy.dataId);\n      var fltValues = this.readSync(filter.dataId);\n\n      var _filter$strides = _slicedToArray(filter.strides, 3),\n          fltS0 = _filter$strides[0],\n          fltS1 = _filter$strides[1],\n          fltS2 = _filter$strides[2];\n\n      var batchSize = convInfo.batchSize,\n          filterHeight = convInfo.filterHeight,\n          filterWidth = convInfo.filterWidth,\n          inChannels = convInfo.inChannels,\n          inHeight = convInfo.inHeight,\n          inWidth = convInfo.inWidth,\n          outChannels = convInfo.outChannels,\n          outHeight = convInfo.outHeight,\n          outWidth = convInfo.outWidth,\n          strideHeight = convInfo.strideHeight,\n          strideWidth = convInfo.strideWidth,\n          dataFormat = convInfo.dataFormat;\n      var topPad = filterHeight - 1 - convInfo.padInfo.top;\n      var leftPad = filterWidth - 1 - convInfo.padInfo.left;\n      var isChannelsLast = dataFormat === 'channelsLast';\n      var xBatchStride = dx.strides[0];\n      var xRowStride = isChannelsLast ? dx.strides[1] : dx.strides[2];\n      var xColStride = isChannelsLast ? dx.strides[2] : 1;\n      var xChannelStride = isChannelsLast ? 1 : dx.strides[1];\n      var yBatchStride = dy.strides[0];\n      var yRowStride = isChannelsLast ? dy.strides[1] : dy.strides[2];\n      var yColStride = isChannelsLast ? dy.strides[2] : 1;\n      var yChannelStride = isChannelsLast ? 1 : dy.strides[1];\n\n      for (var b = 0; b < batchSize; ++b) {\n        for (var d1 = 0; d1 < inChannels; ++d1) {\n          for (var xR = 0; xR < inHeight; ++xR) {\n            var xRCorner = xR - topPad;\n            var xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));\n            var yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);\n\n            for (var xC = 0; xC < inWidth; ++xC) {\n              var xCCorner = xC - leftPad;\n              var xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));\n              var yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);\n              var dotProd = 0;\n\n              for (var yR = xRMin; yR < yRMax; ++yR) {\n                var wR = yR * strideHeight - xRCorner;\n\n                for (var yC = xCMin; yC < yCMax; ++yC) {\n                  var wC = yC * strideWidth - xCCorner;\n                  var dyOffset = yBatchStride * b + yRowStride * yR + yColStride * yC;\n                  var fltOffset = fltS0 * (filterHeight - 1 - wR) + fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;\n\n                  for (var d2 = 0; d2 < outChannels; ++d2) {\n                    var pixel = dyValues[dyOffset + yChannelStride * d2];\n                    var weight = fltValues[fltOffset + d2];\n                    dotProd += pixel * weight;\n                  }\n                }\n              }\n\n              var dxOffset = xBatchStride * b + xRowStride * xR + xColStride * xC + xChannelStride * d1;\n              dxValues[dxOffset] = dotProd;\n            }\n          }\n        }\n      }\n\n      return dx.toTensor();\n    }\n  }, {\n    key: \"conv3dDerInput\",\n    value: function conv3dDerInput(dy, filter, convInfo) {\n      var dx = tf.buffer(convInfo.inShape, 'float32');\n      var dxValues = dx.values;\n\n      var _dx$strides = _slicedToArray(dx.strides, 4),\n          dxS0 = _dx$strides[0],\n          dxS1 = _dx$strides[1],\n          dxS2 = _dx$strides[2],\n          dxS3 = _dx$strides[3];\n\n      var dyValues = this.readSync(dy.dataId);\n\n      var _dy$strides = _slicedToArray(dy.strides, 4),\n          dyS0 = _dy$strides[0],\n          dyS1 = _dy$strides[1],\n          dyS2 = _dy$strides[2],\n          dyS3 = _dy$strides[3];\n\n      var fltValues = this.readSync(filter.dataId);\n\n      var _filter$strides2 = _slicedToArray(filter.strides, 4),\n          fltS0 = _filter$strides2[0],\n          fltS1 = _filter$strides2[1],\n          fltS2 = _filter$strides2[2],\n          fltS3 = _filter$strides2[3];\n\n      var batchSize = convInfo.batchSize,\n          filterDepth = convInfo.filterDepth,\n          filterHeight = convInfo.filterHeight,\n          filterWidth = convInfo.filterWidth,\n          inChannels = convInfo.inChannels,\n          inDepth = convInfo.inDepth,\n          inHeight = convInfo.inHeight,\n          inWidth = convInfo.inWidth,\n          outChannels = convInfo.outChannels,\n          outDepth = convInfo.outDepth,\n          outHeight = convInfo.outHeight,\n          outWidth = convInfo.outWidth,\n          strideDepth = convInfo.strideDepth,\n          strideHeight = convInfo.strideHeight,\n          strideWidth = convInfo.strideWidth;\n      var frontPad = filterDepth - 1 - convInfo.padInfo.front;\n      var topPad = filterHeight - 1 - convInfo.padInfo.top;\n      var leftPad = filterWidth - 1 - convInfo.padInfo.left;\n\n      for (var b = 0; b < batchSize; ++b) {\n        for (var d1 = 0; d1 < inChannels; ++d1) {\n          // Frames of depth\n          for (var xF = 0; xF < inDepth; ++xF) {\n            var xFCorner = xF - frontPad;\n            var xFMin = Math.max(0, Math.ceil(xFCorner / strideDepth));\n            var yFMax = Math.min(outDepth, (filterDepth + xFCorner) / strideDepth); // Rows as per standard 2d matrix notation\n\n            for (var xR = 0; xR < inHeight; ++xR) {\n              var xRCorner = xR - topPad;\n              var xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));\n              var yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight); // Columns as per standard 2d matrix notation\n\n              for (var xC = 0; xC < inWidth; ++xC) {\n                var xCCorner = xC - leftPad;\n                var xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));\n                var yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);\n                var dotProd = 0;\n\n                for (var yF = xFMin; yF < yFMax; ++yF) {\n                  var wF = yF * strideDepth - xFCorner;\n\n                  for (var yR = xRMin; yR < yRMax; ++yR) {\n                    var wR = yR * strideHeight - xRCorner;\n\n                    for (var yC = xCMin; yC < yCMax; ++yC) {\n                      var wC = yC * strideWidth - xCCorner;\n                      var dyOffset = dyS0 * b + dyS1 * yF + dyS2 * yR + dyS3 * yC;\n                      var fltOffset = fltS0 * (filterDepth - 1 - wF) + fltS1 * (filterHeight - 1 - wR) + fltS2 * (filterWidth - 1 - wC) + fltS3 * d1;\n\n                      for (var d2 = 0; d2 < outChannels; ++d2) {\n                        var pixel = dyValues[dyOffset + d2];\n                        var weight = fltValues[fltOffset + d2];\n                        dotProd += pixel * weight;\n                      }\n                    }\n                  }\n                }\n\n                dxValues[dxS0 * b + dxS1 * xF + dxS2 * xR + dxS3 * xC + d1] = dotProd;\n              }\n            }\n          }\n        }\n      }\n\n      return dx.toTensor();\n    }\n  }, {\n    key: \"conv2dDerFilter\",\n    value: function conv2dDerFilter(x, dy, convInfo) {\n      assertNotComplex([x, dy], 'conv2dDerFilter');\n      var strideHeight = convInfo.strideHeight;\n      var strideWidth = convInfo.strideWidth;\n      var filterHeight = convInfo.filterHeight;\n      var filterWidth = convInfo.filterWidth;\n      var isChannelsLast = convInfo.dataFormat === 'channelsLast';\n      var dW = tf.buffer(convInfo.filterShape, 'float32');\n      var leftPad = convInfo.padInfo.left;\n      var topPad = convInfo.padInfo.top;\n      var xBuf = this.bufferSync(x);\n      var dyBuf = this.bufferSync(dy);\n\n      for (var wR = 0; wR < filterHeight; ++wR) {\n        var yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));\n        var yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);\n\n        for (var wC = 0; wC < filterWidth; ++wC) {\n          var yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));\n          var yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);\n\n          for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {\n            for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {\n              // Need to convolve.\n              var dotProd = 0;\n\n              for (var b = 0; b < convInfo.batchSize; ++b) {\n                for (var yR = yRMin; yR < yRMax; ++yR) {\n                  var xR = wR + yR * strideHeight - topPad;\n\n                  for (var yC = yCMin; yC < yCMax; ++yC) {\n                    var xC = wC + yC * strideWidth - leftPad;\n\n                    if (isChannelsLast) {\n                      dotProd += xBuf.get(b, xR, xC, d1) * dyBuf.get(b, yR, yC, d2);\n                    } else {\n                      dotProd += xBuf.get(b, d1, xR, xC) * dyBuf.get(b, d2, yR, yC);\n                    }\n                  }\n                }\n              }\n\n              dW.set(dotProd, wR, wC, d1, d2);\n            }\n          }\n        }\n      }\n\n      return dW.toTensor();\n    }\n  }, {\n    key: \"conv3dDerFilter\",\n    value: function conv3dDerFilter(x, dy, convInfo) {\n      var strideDepth = convInfo.strideDepth;\n      var strideHeight = convInfo.strideHeight;\n      var strideWidth = convInfo.strideWidth;\n      var filterDepth = convInfo.filterDepth;\n      var filterHeight = convInfo.filterHeight;\n      var filterWidth = convInfo.filterWidth;\n      var dw = tf.buffer(convInfo.filterShape, 'float32');\n      var dwValues = dw.values;\n\n      var _dw$strides = _slicedToArray(dw.strides, 4),\n          dwS0 = _dw$strides[0],\n          dwS1 = _dw$strides[1],\n          dwS2 = _dw$strides[2],\n          dwS3 = _dw$strides[3];\n\n      var dyValues = this.readSync(dy.dataId);\n\n      var _dy$strides2 = _slicedToArray(dy.strides, 4),\n          dyS0 = _dy$strides2[0],\n          dyS1 = _dy$strides2[1],\n          dyS2 = _dy$strides2[2],\n          dyS3 = _dy$strides2[3];\n\n      var xValues = this.readSync(x.dataId);\n\n      var _x$strides = _slicedToArray(x.strides, 4),\n          xS0 = _x$strides[0],\n          xS1 = _x$strides[1],\n          xS2 = _x$strides[2],\n          xS3 = _x$strides[3];\n\n      var frontPad = convInfo.padInfo.front;\n      var leftPad = convInfo.padInfo.left;\n      var topPad = convInfo.padInfo.top;\n\n      for (var wF = 0; wF < filterDepth; ++wF) {\n        var yFMin = Math.max(0, Math.ceil((frontPad - wF) / strideDepth));\n        var yFMax = Math.min(convInfo.outDepth, (convInfo.inDepth + frontPad - wF) / strideDepth);\n        var wOffset1 = wF * dwS0;\n\n        for (var wR = 0; wR < filterHeight; ++wR) {\n          var yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));\n          var yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);\n          var wOffset2 = wR * dwS1 + wOffset1;\n\n          for (var wC = 0; wC < filterWidth; ++wC) {\n            var yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));\n            var yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);\n            var wOffset3 = wC * dwS2 + wOffset2;\n\n            for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {\n              var wOffset4 = d1 * dwS3 + wOffset3;\n\n              for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {\n                var dotProd = 0;\n\n                for (var b = 0; b < convInfo.batchSize; ++b) {\n                  var xOffset1 = b * xS0;\n                  var yOffset1 = b * dyS0;\n\n                  for (var yF = yFMin; yF < yFMax; ++yF) {\n                    var xF = wF + yF * strideDepth - frontPad;\n                    var xOffset2 = xF * xS1 + xOffset1;\n                    var yOffset2 = yF * dyS1 + yOffset1;\n\n                    for (var yR = yRMin; yR < yRMax; ++yR) {\n                      var xR = wR + yR * strideHeight - topPad;\n                      var xOffset3 = xR * xS2 + xOffset2;\n                      var yOffset3 = yR * dyS2 + yOffset2;\n\n                      for (var yC = yCMin; yC < yCMax; ++yC) {\n                        var xC = wC + yC * strideWidth - leftPad;\n                        var xOffset4 = xC * xS3 + xOffset3;\n                        var yOffset4 = yC * dyS3 + yOffset3;\n                        dotProd += xValues[xOffset4 + d1] * dyValues[yOffset4 + d2];\n                      }\n                    }\n                  }\n                }\n\n                dwValues[wOffset4 + d2] = dotProd;\n              }\n            }\n          }\n        }\n      }\n\n      return dw.toTensor();\n    }\n  }, {\n    key: \"fusedDepthwiseConv2D\",\n    value: function fusedDepthwiseConv2D(_ref7) {\n      var input = _ref7.input,\n          filter = _ref7.filter,\n          convInfo = _ref7.convInfo,\n          bias = _ref7.bias,\n          activation = _ref7.activation,\n          preluActivationWeights = _ref7.preluActivationWeights;\n      var result = this.depthwiseConv2D(input, filter, convInfo);\n\n      if (bias) {\n        result = this.add(result, bias);\n      }\n\n      if (activation) {\n        result = mapActivation(this, result, activation, preluActivationWeights);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"depthwiseConv2D\",\n    value: function depthwiseConv2D(x, filter, convInfo) {\n      assertNotComplex([x, filter], 'depthwiseConv2D');\n      var filterHeight = convInfo.filterHeight;\n      var filterWidth = convInfo.filterWidth;\n      var dilationHeight = convInfo.dilationHeight;\n      var dilationWidth = convInfo.dilationWidth;\n      var padLeft = convInfo.padInfo.left;\n      var padTop = convInfo.padInfo.top;\n      var chMul = convInfo.outChannels / convInfo.inChannels;\n      var y = tf.buffer(convInfo.outShape, x.dtype);\n      var xVals = this.readSync(x.dataId);\n      var wVals = this.readSync(filter.dataId);\n      var yVals = y.values;\n\n      for (var b = 0; b < convInfo.batchSize; ++b) {\n        var xOffset1 = b * x.strides[0];\n        var yOffset1 = b * y.strides[0];\n\n        for (var yR = 0; yR < convInfo.outHeight; ++yR) {\n          var yOffset2 = yOffset1 + yR * y.strides[1];\n          var xRCorner = yR * convInfo.strideHeight - padLeft;\n\n          for (var wR = 0; wR < filterHeight; ++wR) {\n            var xR = xRCorner + wR * dilationHeight;\n\n            if (xR < 0 || xR >= convInfo.inHeight) {\n              continue;\n            }\n\n            var wOffset1 = wR * filter.strides[0];\n            var xOffset2 = xOffset1 + xR * x.strides[1];\n\n            for (var yC = 0; yC < convInfo.outWidth; ++yC) {\n              var yOffset3 = yOffset2 + yC * y.strides[2];\n              var xCCorner = yC * convInfo.strideWidth - padTop;\n\n              for (var wC = 0; wC < filterWidth; ++wC) {\n                var xC = xCCorner + wC * dilationWidth;\n\n                if (xC < 0 || xC >= convInfo.inWidth) {\n                  continue;\n                }\n\n                var wOffset2 = wOffset1 + wC * filter.strides[1];\n                var xOffset3 = xOffset2 + xC * convInfo.inChannels;\n                var yOffset4 = yOffset3;\n                var wOffset3 = wOffset2;\n\n                for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {\n                  var xVal = xVals[xOffset3 + d1];\n\n                  for (var q = 0; q < chMul; ++q) {\n                    yVals[yOffset4 + q] += xVal * wVals[wOffset3 + q];\n                  }\n\n                  yOffset4 += chMul;\n                  wOffset3 += chMul;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return y.toTensor();\n    }\n  }, {\n    key: \"depthwiseConv2DDerInput\",\n    value: function depthwiseConv2DDerInput(dy, filter, convInfo) {\n      assertNotComplex([dy, filter], 'depthwiseConv2DDerInput');\n      var dx = tf.buffer(convInfo.inShape, 'float32');\n      var dxValues = dx.values;\n\n      var _dx$strides2 = _slicedToArray(dx.strides, 3),\n          dxS0 = _dx$strides2[0],\n          dxS1 = _dx$strides2[1],\n          dxS2 = _dx$strides2[2];\n\n      var dyValues = this.readSync(dy.dataId);\n\n      var _dy$strides3 = _slicedToArray(dy.strides, 3),\n          dyS0 = _dy$strides3[0],\n          dyS1 = _dy$strides3[1],\n          dyS2 = _dy$strides3[2];\n\n      var fltValues = this.readSync(filter.dataId);\n\n      var _filter$strides3 = _slicedToArray(filter.strides, 3),\n          fltS0 = _filter$strides3[0],\n          fltS1 = _filter$strides3[1],\n          fltS2 = _filter$strides3[2];\n\n      var batchSize = convInfo.batchSize,\n          filterHeight = convInfo.filterHeight,\n          filterWidth = convInfo.filterWidth,\n          inChannels = convInfo.inChannels,\n          inHeight = convInfo.inHeight,\n          inWidth = convInfo.inWidth,\n          outChannels = convInfo.outChannels,\n          outHeight = convInfo.outHeight,\n          outWidth = convInfo.outWidth,\n          strideHeight = convInfo.strideHeight,\n          strideWidth = convInfo.strideWidth;\n      var topPad = filterHeight - 1 - convInfo.padInfo.top;\n      var leftPad = filterWidth - 1 - convInfo.padInfo.left;\n      var chMul = outChannels / inChannels;\n\n      for (var b = 0; b < batchSize; ++b) {\n        for (var d1 = 0; d1 < inChannels; ++d1) {\n          for (var xR = 0; xR < inHeight; ++xR) {\n            var xRCorner = xR - topPad;\n            var xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));\n            var yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);\n\n            for (var xC = 0; xC < inWidth; ++xC) {\n              var xCCorner = xC - leftPad;\n              var xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));\n              var yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);\n              var dotProd = 0;\n\n              for (var yR = xRMin; yR < yRMax; ++yR) {\n                var wR = yR * strideHeight - xRCorner;\n\n                for (var yC = xCMin; yC < yCMax; ++yC) {\n                  var wC = yC * strideWidth - xCCorner;\n                  var dyOffset = dyS0 * b + dyS1 * yR + dyS2 * yC;\n                  var fltOffset = fltS0 * (filterHeight - 1 - wR) + fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;\n\n                  for (var dm = 0; dm < chMul; ++dm) {\n                    var d2 = d1 * chMul + dm;\n                    var pixel = dyValues[dyOffset + d2];\n                    var weight = fltValues[fltOffset + dm];\n                    dotProd += pixel * weight;\n                  }\n                }\n              }\n\n              dxValues[dxS0 * b + dxS1 * xR + dxS2 * xC + d1] = dotProd;\n            }\n          }\n        }\n      }\n\n      return dx.toTensor();\n    }\n  }, {\n    key: \"depthwiseConv2DDerFilter\",\n    value: function depthwiseConv2DDerFilter(x, dy, convInfo) {\n      assertNotComplex([x, dy], 'depthwiseConv2DDerFilter');\n      var strideHeight = convInfo.strideHeight;\n      var strideWidth = convInfo.strideWidth;\n      var filterHeight = convInfo.filterHeight;\n      var filterWidth = convInfo.filterWidth;\n      var dW = tf.buffer(convInfo.filterShape, 'float32');\n      var leftPad = convInfo.padInfo.left;\n      var topPad = convInfo.padInfo.top;\n      var chMul = convInfo.outChannels / convInfo.inChannels;\n      var xBuf = this.bufferSync(x);\n      var dyBuf = this.bufferSync(dy);\n\n      for (var wR = 0; wR < filterHeight; ++wR) {\n        var yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));\n        var yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);\n\n        for (var wC = 0; wC < filterWidth; ++wC) {\n          var yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));\n          var yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);\n\n          for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {\n            var d1 = Math.trunc(d2 / chMul);\n            var dm = d2 % chMul;\n            var dotProd = 0;\n\n            for (var b = 0; b < convInfo.batchSize; ++b) {\n              for (var yR = yRMin; yR < yRMax; ++yR) {\n                var xR = wR + yR * strideHeight - topPad;\n\n                for (var yC = yCMin; yC < yCMax; ++yC) {\n                  var xC = wC + yC * strideWidth - leftPad;\n                  dotProd += xBuf.get(b, xR, xC, d1) * dyBuf.get(b, yR, yC, d2);\n                }\n              }\n            }\n\n            dW.set(dotProd, wR, wC, d1, dm);\n          }\n        }\n      }\n\n      return dW.toTensor();\n    }\n  }, {\n    key: \"tile\",\n    value: function tile(x, reps) {\n      assertNotComplex(x, 'tile');\n      return _tile(this.bufferSync(x), reps);\n    }\n  }, {\n    key: \"gather\",\n    value: function gather(x, indices, axis) {\n      assertNotComplex([x, indices], 'gather');\n      var newShape = x.shape.slice();\n      var indicesValues = this.readSync(indices.dataId);\n      newShape[axis] = indicesValues.length;\n      var result = tf.buffer(newShape, x.dtype);\n      var xBuf = this.bufferSync(x);\n\n      for (var i = 0; i < result.size; ++i) {\n        var newLoc = result.indexToLoc(i);\n        var originalLoc = newLoc.slice();\n        originalLoc[axis] = indicesValues[newLoc[axis]];\n        var originalIndex = xBuf.locToIndex(originalLoc);\n        result.values[i] = xBuf.values[originalIndex];\n      }\n\n      return result.toTensor();\n    }\n  }, {\n    key: \"batchToSpaceND\",\n    value: function batchToSpaceND(x, blockShape, crops) {\n      assertNotComplex([x], 'batchToSpaceND');\n      var prod = blockShape.reduce(function (a, b) {\n        return a * b;\n      });\n      var reshaped = backend_util.getReshaped(x.shape, blockShape, prod);\n      var permuted = backend_util.getPermuted(reshaped.length, blockShape.length);\n      var reshapedPermuted = backend_util.getReshapedPermuted(x.shape, blockShape, prod);\n      var sliceBeginCoords = backend_util.getSliceBeginCoords(crops, blockShape.length);\n      var sliceSize = backend_util.getSliceSize(reshapedPermuted, crops, blockShape.length);\n      return tf.transpose(x.reshape(reshaped), permuted).reshape(reshapedPermuted).slice(sliceBeginCoords, sliceSize);\n    }\n  }, {\n    key: \"maxPool\",\n    value: function maxPool(x, convInfo) {\n      assertNotComplex(x, 'maxPool');\n      var xValues = this.readSync(x.dataId);\n      return pool(xValues, x.shape, x.dtype, x.strides, convInfo, 'max').toTensor();\n    }\n  }, {\n    key: \"maxPoolBackprop\",\n    value: function maxPoolBackprop(dy, x, y, convInfo) {\n      assertNotComplex([x, y], 'maxPoolBackprop');\n      var xValues = this.readSync(x.dataId);\n      var maxPosBuf = buffer(convInfo.outShape, x.dtype, maxPoolPositions(xValues, x.shape, x.dtype, convInfo).values);\n      var strideHeight = convInfo.strideHeight;\n      var strideWidth = convInfo.strideWidth;\n      var dilationHeight = convInfo.dilationHeight;\n      var dilationWidth = convInfo.dilationWidth;\n      var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n      var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n      var padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n      var padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n      var dx = tf.buffer(x.shape, 'float32');\n      var dyBuf = this.bufferSync(dy);\n\n      for (var b = 0; b < convInfo.batchSize; ++b) {\n        for (var d = 0; d < convInfo.inChannels; ++d) {\n          for (var dxR = 0; dxR < convInfo.inHeight; ++dxR) {\n            for (var dxC = 0; dxC < convInfo.inWidth; ++dxC) {\n              // Shader code begins.\n              var dyRCorner = dxR - padTop;\n              var dyCCorner = dxC - padLeft;\n              var dotProd = 0;\n\n              for (var wR = 0; wR < effectiveFilterHeight; wR += dilationHeight) {\n                var dyR = (dyRCorner + wR) / strideHeight;\n\n                if (dyR < 0 || dyR >= convInfo.outHeight || Math.floor(dyR) !== dyR) {\n                  continue;\n                }\n\n                for (var wC = 0; wC < effectiveFilterWidth; wC += dilationWidth) {\n                  var dyC = (dyCCorner + wC) / strideWidth;\n\n                  if (dyC < 0 || dyC >= convInfo.outWidth || Math.floor(dyC) !== dyC) {\n                    continue;\n                  }\n\n                  var maxPos = effectiveFilterHeight * effectiveFilterWidth - 1 - maxPosBuf.get(b, dyR, dyC, d);\n                  var curPos = wR * effectiveFilterWidth + wC;\n                  var mask = maxPos === curPos ? 1 : 0;\n\n                  if (mask === 0) {\n                    continue;\n                  }\n\n                  var pixel = dyBuf.get(b, dyR, dyC, d);\n                  dotProd += pixel * mask;\n                }\n              }\n\n              dx.set(dotProd, b, dxR, dxC, d);\n            }\n          }\n        }\n      }\n\n      return dx.toTensor();\n    }\n  }, {\n    key: \"avgPoolBackprop\",\n    value: function avgPoolBackprop(dy, x, convInfo) {\n      assertNotComplex([dy, x], 'avgPoolBackprop');\n      var strideHeight = convInfo.strideHeight;\n      var strideWidth = convInfo.strideWidth;\n      var filterHeight = convInfo.filterHeight;\n      var filterWidth = convInfo.filterWidth;\n      var dilationHeight = convInfo.dilationHeight;\n      var dilationWidth = convInfo.dilationWidth;\n      var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n      var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n      var padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n      var padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n      var dx = tf.buffer(x.shape, 'float32');\n      var avgMultiplier = 1 / (filterHeight * filterWidth);\n      var dyBuf = this.bufferSync(dy);\n\n      for (var b = 0; b < convInfo.batchSize; ++b) {\n        for (var d = 0; d < convInfo.inChannels; ++d) {\n          for (var dxR = 0; dxR < convInfo.inHeight; ++dxR) {\n            for (var dxC = 0; dxC < convInfo.inWidth; ++dxC) {\n              // Shader code begins.\n              var dyRCorner = dxR - padTop;\n              var dyCCorner = dxC - padLeft;\n              var dotProd = 0;\n\n              for (var wR = 0; wR < effectiveFilterHeight; wR += dilationHeight) {\n                var dyR = (dyRCorner + wR) / strideHeight;\n\n                if (dyR < 0 || dyR >= convInfo.outHeight || Math.floor(dyR) !== dyR) {\n                  continue;\n                }\n\n                for (var wC = 0; wC < effectiveFilterWidth; wC += dilationWidth) {\n                  var dyC = (dyCCorner + wC) / strideWidth;\n\n                  if (dyC < 0 || dyC >= convInfo.outWidth || Math.floor(dyC) !== dyC) {\n                    continue;\n                  }\n\n                  var pixel = dyBuf.get(b, dyR, dyC, d);\n                  dotProd += pixel;\n                }\n              }\n\n              dx.set(dotProd * avgMultiplier, b, dxR, dxC, d);\n            }\n          }\n        }\n      }\n\n      return dx.toTensor();\n    }\n  }, {\n    key: \"pool3d\",\n    value: function pool3d(x, convInfo, poolType) {\n      assertNotComplex(x, 'pool3d');\n      var strideDepth = convInfo.strideDepth;\n      var strideHeight = convInfo.strideHeight;\n      var strideWidth = convInfo.strideWidth;\n      var dilationDepth = convInfo.dilationDepth;\n      var dilationHeight = convInfo.dilationHeight;\n      var dilationWidth = convInfo.dilationWidth;\n      var effectiveFilterDepth = convInfo.effectiveFilterDepth;\n      var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n      var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n      var padFront = convInfo.padInfo.front;\n      var padTop = convInfo.padInfo.top;\n      var padLeft = convInfo.padInfo.left;\n      var initialValue = poolType === 'max' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n      var xValues = this.readSync(x.dataId);\n      var output = tf.buffer(convInfo.outShape, x.dtype);\n      var outputVals = output.values;\n      var outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];\n      var outputDepthStrides = convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];\n      var outputRowStrides = convInfo.outShape[3] * convInfo.outShape[4];\n      var outputColStrides = convInfo.outShape[4];\n\n      for (var batch = 0; batch < convInfo.batchSize; ++batch) {\n        var outputBatchOffset = batch * outputBatchStrides;\n        var inputBatchOffset = batch * x.strides[0];\n\n        for (var channel = 0; channel < convInfo.inChannels; ++channel) {\n          for (var yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n            var xDepthCorner = yDepth * strideDepth - padFront;\n            var xDepthMin = xDepthCorner;\n\n            while (xDepthMin < 0) {\n              xDepthMin += dilationDepth;\n            }\n\n            var xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n            var outputDepthOffset = outputBatchOffset + yDepth * outputDepthStrides;\n\n            for (var yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n              var xRowCorner = yRow * strideHeight - padTop;\n              var xRowMin = xRowCorner;\n\n              while (xRowMin < 0) {\n                xRowMin += dilationHeight;\n              }\n\n              var xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n              var outputRowOffset = outputDepthOffset + yRow * outputRowStrides;\n\n              for (var yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n                var xColCorner = yCol * strideWidth - padLeft;\n                var xColMin = xColCorner;\n\n                while (xColMin < 0) {\n                  xColMin += dilationWidth;\n                }\n\n                var xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner); // Shader code begins\n\n                var outputColOffset = outputRowOffset + yCol * outputColStrides;\n                var minMaxValue = initialValue;\n                var avgValue = 0;\n                var count = 0;\n\n                for (var xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {\n                  var xDepthOffset = inputBatchOffset + xDepth * x.strides[1];\n\n                  for (var xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                    var xRowOffset = xDepthOffset + xRow * x.strides[2];\n\n                    for (var xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {\n                      var xColOffset = xRowOffset + xCol * x.strides[3];\n                      var pixel = xValues[xColOffset + channel];\n\n                      if (poolType === 'max' && pixel > minMaxValue) {\n                        minMaxValue = pixel;\n                      } else if (poolType === 'avg') {\n                        avgValue += pixel;\n                        count++;\n                      }\n\n                      if (isNaN(minMaxValue)) {\n                        break;\n                      }\n                    }\n\n                    if (isNaN(minMaxValue)) {\n                      break;\n                    }\n                  }\n\n                  if (isNaN(minMaxValue)) {\n                    break;\n                  }\n                }\n\n                var outputOffset = outputColOffset + channel;\n                outputVals[outputOffset] = poolType === 'avg' ? avgValue / count : minMaxValue;\n              }\n            }\n          }\n        }\n      }\n\n      return output.toTensor();\n    }\n  }, {\n    key: \"avgPool3d\",\n    value: function avgPool3d(x, convInfo) {\n      assertNotComplex(x, 'avgPool3d');\n      return this.pool3d(x, convInfo, 'avg').toFloat();\n    }\n  }, {\n    key: \"avgPool3dBackprop\",\n    value: function avgPool3dBackprop(dy, x, convInfo) {\n      assertNotComplex([dy, x], 'avgPool3dBackprop');\n      var strideDepth = convInfo.strideDepth;\n      var strideHeight = convInfo.strideHeight;\n      var strideWidth = convInfo.strideWidth;\n      var filterDepth = convInfo.filterDepth;\n      var filterHeight = convInfo.filterHeight;\n      var filterWidth = convInfo.filterWidth;\n      var dilationDepth = convInfo.dilationDepth;\n      var dilationHeight = convInfo.dilationHeight;\n      var dilationWidth = convInfo.dilationWidth;\n      var effectiveFilterDepth = convInfo.effectiveFilterDepth;\n      var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n      var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n      var padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n      var padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n      var padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n      var dx = tf.buffer(x.shape, 'float32');\n      var avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);\n      var dyBuf = this.bufferSync(dy);\n\n      for (var batch = 0; batch < convInfo.batchSize; ++batch) {\n        for (var channel = 0; channel < convInfo.inChannels; ++channel) {\n          for (var dxDepth = 0; dxDepth < convInfo.inDepth; ++dxDepth) {\n            for (var dxRow = 0; dxRow < convInfo.inHeight; ++dxRow) {\n              for (var dxCol = 0; dxCol < convInfo.inWidth; ++dxCol) {\n                // Shader code begins.\n                var dyDepthCorner = dxDepth - padFront;\n                var dyRowCorner = dxRow - padTop;\n                var dyColCorner = dxCol - padLeft;\n                var dotProd = 0;\n\n                for (var wDepth = 0; wDepth < effectiveFilterDepth; wDepth += dilationDepth) {\n                  var dyDepth = (dyDepthCorner + wDepth) / strideDepth;\n\n                  if (dyDepth < 0 || dyDepth >= convInfo.outDepth || Math.floor(dyDepth) !== dyDepth) {\n                    continue;\n                  }\n\n                  for (var wRow = 0; wRow < effectiveFilterHeight; wRow += dilationHeight) {\n                    var dyRow = (dyRowCorner + wRow) / strideHeight;\n\n                    if (dyRow < 0 || dyRow >= convInfo.outHeight || Math.floor(dyRow) !== dyRow) {\n                      continue;\n                    }\n\n                    for (var wCol = 0; wCol < effectiveFilterWidth; wCol += dilationWidth) {\n                      var dyCol = (dyColCorner + wCol) / strideWidth;\n\n                      if (dyCol < 0 || dyCol >= convInfo.outWidth || Math.floor(dyCol) !== dyCol) {\n                        continue;\n                      }\n\n                      var pixel = dyBuf.get(batch, dyDepth, dyRow, dyCol, channel);\n                      dotProd += pixel;\n                    }\n                  }\n                }\n\n                dx.set(dotProd * avgMultiplier, batch, dxDepth, dxRow, dxCol, channel);\n              }\n            }\n          }\n        }\n      }\n\n      return dx.toTensor();\n    }\n  }, {\n    key: \"maxPool3d\",\n    value: function maxPool3d(x, convInfo) {\n      assertNotComplex(x, 'maxPool3d');\n      return this.pool3d(x, convInfo, 'max').toFloat();\n    }\n  }, {\n    key: \"maxPool3dPositions\",\n    value: function maxPool3dPositions(x, convInfo) {\n      var maxPositions = tf.buffer(convInfo.outShape, 'int32');\n      var strideDepth = convInfo.strideDepth;\n      var strideHeight = convInfo.strideHeight;\n      var strideWidth = convInfo.strideWidth;\n      var dilationDepth = convInfo.dilationDepth;\n      var dilationHeight = convInfo.dilationHeight;\n      var dilationWidth = convInfo.dilationWidth;\n      var effectiveFilterDepth = convInfo.effectiveFilterDepth;\n      var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n      var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n      var padFront = convInfo.padInfo.front;\n      var padTop = convInfo.padInfo.top;\n      var padLeft = convInfo.padInfo.left;\n      var xBuf = this.bufferSync(x);\n\n      for (var batch = 0; batch < convInfo.batchSize; ++batch) {\n        for (var channel = 0; channel < convInfo.inChannels; ++channel) {\n          for (var yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n            var xDepthCorner = yDepth * strideDepth - padFront;\n            var xDepthMin = xDepthCorner;\n\n            while (xDepthMin < 0) {\n              xDepthMin += dilationDepth;\n            }\n\n            var xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n\n            for (var yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n              var xRowCorner = yRow * strideHeight - padTop;\n              var xRowMin = xRowCorner;\n\n              while (xRowMin < 0) {\n                xRowMin += dilationHeight;\n              }\n\n              var xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n\n              for (var yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n                var xColCorner = yCol * strideWidth - padLeft;\n                var xColMin = xColCorner;\n\n                while (xColMin < 0) {\n                  xColMin += dilationWidth;\n                }\n\n                var xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner); // Shader code begins\n\n                var maxValue = Number.NEGATIVE_INFINITY;\n                var maxPosition = -1;\n\n                for (var xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {\n                  var wDepth = xDepth - xDepthCorner;\n\n                  for (var xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                    var wRow = xRow - xRowCorner;\n\n                    for (var xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {\n                      var wCol = xCol - xColCorner;\n                      var pixel = xBuf.get(batch, xDepth, xRow, xCol, channel);\n\n                      if (pixel >= maxValue) {\n                        maxValue = pixel;\n                        maxPosition = wDepth * effectiveFilterHeight * effectiveFilterWidth + wRow * effectiveFilterHeight + wCol;\n                      }\n                    }\n                  }\n                }\n\n                maxPositions.set(maxPosition, batch, yDepth, yRow, yCol, channel);\n              }\n            }\n          }\n        }\n      }\n\n      return maxPositions.toTensor();\n    }\n  }, {\n    key: \"maxPool3dBackprop\",\n    value: function maxPool3dBackprop(dy, x, y, convInfo) {\n      assertNotComplex([x, y], 'maxPool3dBackprop');\n      var maxPositions = this.maxPool3dPositions(x, convInfo);\n      var strideDepth = convInfo.strideDepth;\n      var strideHeight = convInfo.strideHeight;\n      var strideWidth = convInfo.strideWidth;\n      var dilationDepth = convInfo.dilationDepth;\n      var dilationHeight = convInfo.dilationHeight;\n      var dilationWidth = convInfo.dilationWidth;\n      var effectiveFilterDepth = convInfo.effectiveFilterDepth;\n      var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n      var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n      var padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n      var padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n      var padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n      var dx = tf.buffer(x.shape, 'float32');\n      var maxPosBuf = this.bufferSync(maxPositions);\n      var dyBuf = this.bufferSync(dy);\n\n      for (var batch = 0; batch < convInfo.batchSize; ++batch) {\n        for (var channel = 0; channel < convInfo.inChannels; ++channel) {\n          for (var dxDepth = 0; dxDepth < convInfo.inDepth; ++dxDepth) {\n            for (var dxRow = 0; dxRow < convInfo.inHeight; ++dxRow) {\n              for (var dxCol = 0; dxCol < convInfo.inWidth; ++dxCol) {\n                // Shader code begins\n                var dyDepthCorner = dxDepth - padFront;\n                var dyRowCorner = dxRow - padTop;\n                var dyColCorner = dxCol - padLeft;\n                var dotProd = 0;\n\n                for (var wDepth = 0; wDepth < effectiveFilterDepth; wDepth += dilationDepth) {\n                  var dyDepth = (dyDepthCorner + wDepth) / strideDepth;\n\n                  if (dyDepth < 0 || dyDepth >= convInfo.outDepth || Math.floor(dyDepth) !== dyDepth) {\n                    continue;\n                  }\n\n                  for (var wRow = 0; wRow < effectiveFilterHeight; wRow += dilationHeight) {\n                    var dyRow = (dyRowCorner + wRow) / strideHeight;\n\n                    if (dyRow < 0 || dyRow >= convInfo.outHeight || Math.floor(dyRow) !== dyRow) {\n                      continue;\n                    }\n\n                    for (var wCol = 0; wCol < effectiveFilterWidth; wCol += dilationWidth) {\n                      var dyCol = (dyColCorner + wCol) / strideWidth;\n\n                      if (dyCol < 0 || dyCol >= convInfo.outWidth || Math.floor(dyCol) !== dyCol) {\n                        continue;\n                      }\n\n                      var maxPos = effectiveFilterDepth * effectiveFilterHeight * effectiveFilterWidth - 1 - maxPosBuf.get(batch, dyDepth, dyRow, dyCol, channel);\n                      var curPos = wDepth * effectiveFilterHeight * effectiveFilterWidth + wRow * effectiveFilterWidth + wCol;\n                      var mask = maxPos === curPos ? 1 : 0;\n\n                      if (mask === 0) {\n                        continue;\n                      }\n\n                      var pixel = dyBuf.get(batch, dyDepth, dyRow, dyCol, channel);\n                      dotProd += pixel * mask;\n                    }\n                  }\n                }\n\n                dx.set(dotProd, batch, dxDepth, dxRow, dxCol, channel);\n              }\n            }\n          }\n        }\n      }\n\n      return dx.toTensor();\n    }\n  }, {\n    key: \"cast\",\n    value: function cast(x, dtype) {\n      return backend_util.castTensor(x, dtype, this);\n    }\n  }, {\n    key: \"avgPool\",\n    value: function avgPool(x, convInfo) {\n      assertNotComplex(x, 'avgPool');\n      assertNotComplex(x, 'maxPool');\n      var xValues = this.readSync(x.dataId);\n      return pool(xValues, x.shape, x.dtype, x.strides, convInfo, 'avg').toTensor().toFloat();\n    }\n  }, {\n    key: \"resizeBilinear\",\n    value: function resizeBilinear(x, newHeight, newWidth, alignCorners) {\n      assertNotComplex(x, 'resizeBilinear');\n\n      var _x$shape = _slicedToArray(x.shape, 4),\n          batch = _x$shape[0],\n          oldHeight = _x$shape[1],\n          oldWidth = _x$shape[2],\n          numChannels = _x$shape[3];\n\n      var xValues = this.readSync(x.dataId);\n      var result = new Float32Array(util.sizeFromShape([batch, newHeight, newWidth, numChannels]));\n      var effectiveInputSize = [alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight, alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth];\n      var effectiveOutputSize = [alignCorners && newHeight > 1 ? newHeight - 1 : newHeight, alignCorners && newWidth > 1 ? newWidth - 1 : newWidth];\n      var outputIdx = 0;\n      var effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];\n      var effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];\n\n      for (var b = 0; b < batch; b++) {\n        for (var r = 0; r < newHeight; r++) {\n          var sourceFracRow = effectiveRowSizeRatio * r;\n          var sourceRowFloor = Math.floor(sourceFracRow);\n          var rowFrac = sourceFracRow - sourceRowFloor;\n          var sourceRowCeil = Math.min(oldHeight - 1, Math.ceil(sourceFracRow));\n          var topRowOffset = b * x.strides[0] + sourceRowFloor * x.strides[1];\n          var botRowOffset = b * x.strides[0] + sourceRowCeil * x.strides[1];\n\n          for (var c = 0; c < newWidth; c++) {\n            var sourceFracCol = effectiveColSizeRatio * c;\n            var sourceColFloor = Math.floor(sourceFracCol);\n            var colFrac = sourceFracCol - sourceColFloor;\n            var sourceColCeil = Math.min(oldWidth - 1, Math.ceil(sourceFracCol));\n            var topLeftOffest = topRowOffset + sourceColFloor * x.strides[2];\n            var botLeftOffset = botRowOffset + sourceColFloor * x.strides[2];\n            var topRightOffset = topRowOffset + sourceColCeil * x.strides[2];\n            var botRightOffest = botRowOffset + sourceColCeil * x.strides[2];\n\n            for (var d = 0; d < numChannels; d++) {\n              // Begin shader.\n              // Compute the fractional index of the source.\n              var topLeft = xValues[topLeftOffest + d];\n              var bottomLeft = xValues[botLeftOffset + d];\n              var topRight = xValues[topRightOffset + d];\n              var bottomRight = xValues[botRightOffest + d];\n              var top = topLeft + (topRight - topLeft) * colFrac;\n              var bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;\n              var newValue = top + (bottom - top) * rowFrac;\n              result[outputIdx++] = newValue;\n            }\n          }\n        }\n      }\n\n      return tf.tensor(result, [batch, newHeight, newWidth, numChannels]);\n    }\n  }, {\n    key: \"resizeBilinearBackprop\",\n    value: function resizeBilinearBackprop(dy, x, alignCorners) {\n      assertNotComplex([dy, x], 'resizeBilinearBackprop');\n\n      var _x$shape2 = _slicedToArray(x.shape, 4),\n          batch = _x$shape2[0],\n          xHeight = _x$shape2[1],\n          xWidth = _x$shape2[2],\n          depth = _x$shape2[3];\n\n      var _dy$shape = _slicedToArray(dy.shape, 3),\n          yHeight = _dy$shape[1],\n          yWidth = _dy$shape[2];\n\n      var output = new Float32Array(batch * xHeight * xWidth * depth); // In the backwards pass, we want to find the pixels that were generated\n      // for each pixel in the input image the forward pass and add the\n      // corresponding coefficient from dy to the gradient (with some\n      // interpolation).\n\n      var effectiveXSize = [alignCorners && yHeight > 1 ? xHeight - 1 : xHeight, alignCorners && yWidth > 1 ? xWidth - 1 : xWidth];\n      var effectiveYSize = [alignCorners && yHeight > 1 ? yHeight - 1 : yHeight, alignCorners && yWidth > 1 ? yWidth - 1 : yWidth];\n      var heightScale = effectiveXSize[0] / effectiveYSize[0];\n      var widthScale = effectiveXSize[1] / effectiveYSize[1]; // Reference implementation\n      // tslint:disable-next-line:max-line-length\n      // https://github.com/tensorflow/tensorflow/blob/3039375c86a5bbc9610c7725dcaa95d635f87ba2/tensorflow/core/kernels/resize_bilinear_op.cc#L275\n\n      var dyValues = this.readSync(dy.dataId);\n      var offset = 0;\n\n      for (var b = 0; b < batch; b++) {\n        var bOffset = b * x.strides[0];\n\n        for (var r = 0; r < yHeight; r++) {\n          var dxR = r * heightScale;\n          var topDxRIndex = Math.floor(dxR);\n          var bottomDxRIndex = Math.min(Math.ceil(dxR), xHeight - 1);\n          var topDxROffset = bOffset + topDxRIndex * x.strides[1];\n          var bottomDxROffset = bOffset + bottomDxRIndex * x.strides[1];\n          var dxRLerp = dxR - topDxRIndex;\n          var inverseDxRLerp = 1.0 - dxRLerp;\n\n          for (var c = 0; c < yWidth; c++) {\n            var dxC = c * widthScale;\n            var leftDxCIndex = Math.floor(dxC);\n            var rightDxCIndex = Math.min(Math.ceil(dxC), xWidth - 1);\n            var dxCLerp = dxC - leftDxCIndex;\n            var inverseDxCLerp = 1.0 - dxCLerp;\n            var topLeftRCOffset = topDxROffset + leftDxCIndex * x.strides[2];\n            var topRightRCOffset = topDxROffset + rightDxCIndex * x.strides[2];\n            var bottomLeftRCOffset = bottomDxROffset + leftDxCIndex * x.strides[2];\n            var bottomRightRCOffset = bottomDxROffset + rightDxCIndex * x.strides[2];\n            var inverseDxRLerpTimesInverseDxCLerp = inverseDxRLerp * inverseDxCLerp;\n            var inverseDxRLerpTimesDxCLerp = inverseDxRLerp * dxCLerp;\n            var dxRLerpTimesInverseDxCLerp = dxRLerp * inverseDxCLerp;\n            var dxRLerpTimesDxCLerp = dxRLerp * dxCLerp;\n\n            for (var d = 0; d < depth; d++) {\n              var dyVal = dyValues[offset++];\n              output[topLeftRCOffset + d] += dyVal * inverseDxRLerpTimesInverseDxCLerp;\n              output[topRightRCOffset + d] += dyVal * inverseDxRLerpTimesDxCLerp;\n              output[bottomLeftRCOffset + d] += dyVal * dxRLerpTimesInverseDxCLerp;\n              output[bottomRightRCOffset + d] += dyVal * dxRLerpTimesDxCLerp;\n            }\n          }\n        }\n      }\n\n      return tf.tensor4d(output, [batch, xWidth, xHeight, depth], x.dtype);\n    }\n  }, {\n    key: \"resizeNearestNeighbor\",\n    value: function resizeNearestNeighbor(x, newHeight, newWidth, alignCorners) {\n      assertNotComplex(x, 'resizeNearestNeighbor');\n\n      var _x$shape3 = _slicedToArray(x.shape, 4),\n          batch = _x$shape3[0],\n          oldHeight = _x$shape3[1],\n          oldWidth = _x$shape3[2],\n          numChannels = _x$shape3[3];\n\n      var xValues = this.readSync(x.dataId);\n      var output = new Float32Array(batch * newHeight * newWidth * numChannels);\n      var effectiveInputSize = [alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight, alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth];\n      var effectiveOutputSize = [alignCorners && newHeight > 1 ? newHeight - 1 : newHeight, alignCorners && newWidth > 1 ? newWidth - 1 : newWidth];\n      var effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];\n      var effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];\n      var outputOffset = 0;\n\n      for (var b = 0; b < batch; b++) {\n        var batchOffset = b * x.strides[0];\n\n        for (var r = 0; r < newHeight; r++) {\n          var sourceFracRow = effectiveRowSizeRatio * r;\n          var sourceNearestRow = Math.min(oldHeight - 1, alignCorners ? Math.round(sourceFracRow) : Math.floor(sourceFracRow));\n          var rowOffset = batchOffset + sourceNearestRow * x.strides[1];\n\n          for (var c = 0; c < newWidth; c++) {\n            var sourceFracCol = effectiveColSizeRatio * c;\n            var sourceNearestCol = Math.min(oldWidth - 1, alignCorners ? Math.round(sourceFracCol) : Math.floor(sourceFracCol));\n            var colOffset = rowOffset + sourceNearestCol * x.strides[2];\n\n            for (var d = 0; d < numChannels; d++) {\n              // Begin shader.\n              // Compute the fractional index of the source.\n              var newVal = xValues[colOffset + d];\n              output[outputOffset++] = newVal;\n            }\n          }\n        }\n      }\n\n      return tf.tensor(output, [batch, newHeight, newWidth, numChannels], x.dtype);\n    }\n  }, {\n    key: \"resizeNearestNeighborBackprop\",\n    value: function resizeNearestNeighborBackprop(dy, x, alignCorners) {\n      assertNotComplex([dy, x], 'resizeNearestNeighborBackprop');\n\n      var _x$shape4 = _slicedToArray(x.shape, 4),\n          batch = _x$shape4[0],\n          xHeight = _x$shape4[1],\n          xWidth = _x$shape4[2],\n          depth = _x$shape4[3];\n\n      var _dy$shape2 = _slicedToArray(dy.shape, 3),\n          yHeight = _dy$shape2[1],\n          yWidth = _dy$shape2[2];\n\n      var output = new Float32Array(batch * xHeight * xWidth * depth);\n      var dyValues = this.readSync(dy.dataId); // In the backwards pass, we want to find the pixels that were generated\n      // for each pixel in the input image the forward pass\n\n      var effectiveXSize = [alignCorners && yHeight > 1 ? xHeight - 1 : xHeight, alignCorners && yWidth > 1 ? xWidth - 1 : xWidth];\n      var effectiveYSize = [alignCorners && yHeight > 1 ? yHeight - 1 : yHeight, alignCorners && yWidth > 1 ? yWidth - 1 : yWidth];\n      var heightScale = effectiveXSize[0] / effectiveYSize[0];\n      var widthScale = effectiveXSize[1] / effectiveYSize[1];\n      var invHeightScale = 1 / heightScale;\n      var invWidthScale = 1 / widthScale; // This defines the size of the window of values around a particular\n      // index in dy that we want to search for contributions to dx.\n\n      var winHeight = Math.ceil(invHeightScale) * 2 + 2;\n      var winWidth = Math.ceil(invWidthScale) * 2 + 2; // Loop over the output space.\n\n      for (var b = 0; b < batch; b++) {\n        var batchOffset = b * x.strides[0];\n\n        for (var r = 0; r < xHeight; r++) {\n          var rowOffset = batchOffset + r * x.strides[1]; // Compute bounds for where in dy we will look\n\n          var startRLerp = Math.floor(r * invHeightScale);\n          var startDyR = Math.floor(startRLerp - winHeight / 2);\n\n          for (var c = 0; c < xWidth; c++) {\n            var colOffset = rowOffset + c * x.strides[2]; // Compute bounds for where in dy we will look\n\n            var startCLerp = Math.floor(c * invWidthScale);\n            var startDyC = Math.floor(startCLerp - winWidth / 2);\n\n            for (var d = 0; d < depth; d++) {\n              var accum = 0; // loop over dy\n\n              for (var dyRIndex = 0; dyRIndex < winHeight; dyRIndex++) {\n                var dyR = dyRIndex + startDyR; // Guard against the window exceeding the bounds of dy\n\n                if (dyR < 0 || dyR >= yHeight) {\n                  continue;\n                }\n\n                var dyROffset = batchOffset + dyR * dy.strides[1];\n                var sourceFracRow = dyR * heightScale;\n                var sourceNearestRow = Math.min(xHeight - 1, alignCorners ? Math.round(sourceFracRow) : Math.floor(sourceFracRow));\n\n                if (r !== sourceNearestRow) {\n                  continue;\n                }\n\n                for (var dyCIndex = 0; dyCIndex < winWidth; dyCIndex++) {\n                  var dyC = dyCIndex + startDyC; // Guard against the window exceeding the bounds of dy\n\n                  if (dyC < 0 || dyC >= yWidth) {\n                    continue;\n                  }\n\n                  var dyCOffset = dyROffset + dyC * dy.strides[2];\n                  var sourceFracCol = dyC * widthScale;\n                  var sourceNearestCol = Math.min(xWidth - 1, alignCorners ? Math.round(sourceFracCol) : Math.floor(sourceFracCol));\n\n                  if (c === sourceNearestCol) {\n                    accum += dyValues[dyCOffset + d];\n                  }\n                }\n              }\n\n              output[colOffset + d] = accum;\n            }\n          }\n        }\n      }\n\n      return tf.tensor4d(output, x.shape, x.dtype);\n    }\n  }, {\n    key: \"batchNorm\",\n    value: function batchNorm(x, mean, variance, offset, scale, varianceEpsilon) {\n      assertNotComplex([x, mean, variance, scale, offset], 'batchNorm');\n      var xVals = this.readSync(x.dataId);\n      var mVals = this.readSync(mean.dataId);\n      var varVals = this.readSync(variance.dataId);\n      var sVals = scale ? this.readSync(scale.dataId) : new Float32Array([1]);\n      var offVals = offset ? this.readSync(offset.dataId) : new Float32Array([0]);\n      var outVals = new Float32Array(xVals.length);\n      var offValsLength = offVals.length;\n      var sValsLength = sVals.length;\n      var varValsLength = varVals.length;\n      var mValsLength = mVals.length;\n      var offi = 0;\n      var mi = 0;\n      var si = 0;\n      var vi = 0;\n\n      for (var i = 0; i < xVals.length; ++i) {\n        outVals[i] = offVals[offi++] + (xVals[i] - mVals[mi++]) * sVals[si++] / Math.sqrt(varVals[vi++] + varianceEpsilon);\n\n        if (offi >= offValsLength) {\n          offi = 0;\n        }\n\n        if (mi >= mValsLength) {\n          mi = 0;\n        }\n\n        if (si >= sValsLength) {\n          si = 0;\n        }\n\n        if (vi >= varValsLength) {\n          vi = 0;\n        }\n      }\n\n      return tf.tensor4d(outVals, x.shape);\n    }\n  }, {\n    key: \"localResponseNormalization4D\",\n    value: function localResponseNormalization4D(x, depthRadius, bias, alpha, beta) {\n      assertNotComplex(x, 'localResponseNormalization4D');\n      var channels = x.shape[3];\n      var maxD = channels - 1;\n      var xValues = this.readSync(x.dataId);\n      var size = x.size;\n      var result = new Float32Array(size);\n\n      function sumAcrossChannels(offset) {\n        var currentChannel = offset % channels;\n        var beginSumOffset = offset - currentChannel + Math.max(0, currentChannel - depthRadius);\n        var endSumOffset = offset - currentChannel + Math.min(currentChannel + depthRadius, maxD);\n        var sum = 0.0;\n\n        for (; beginSumOffset <= endSumOffset; beginSumOffset++) {\n          var z = xValues[beginSumOffset];\n          sum += z * z;\n        }\n\n        return sum;\n      }\n\n      for (var offset = 0; offset < size; offset++) {\n        var sum = sumAcrossChannels(offset);\n        var val = xValues[offset] * Math.pow(bias + alpha * sum, -beta);\n        result[offset] = val;\n      }\n\n      return tf.tensor4d(result, x.shape);\n    }\n  }, {\n    key: \"LRNGrad\",\n    value: function LRNGrad(dy, inputImage, outputImage, depthRadius, bias, alpha, beta) {\n      assertNotComplex(dy, 'LRNGrad');\n      var channels = dy.shape[3];\n      var dyValues = this.readSync(dy.dataId);\n      var inputImageValues = this.readSync(inputImage.dataId);\n      var outputImageValues = this.readSync(outputImage.dataId);\n      var result = new Float32Array(dy.size);\n      var size = dy.size;\n\n      for (var offset = 0; offset < size; offset++) {\n        var currentChannel = offset % channels;\n        var depthBegin = offset - currentChannel + Math.max(0, currentChannel - depthRadius);\n        var depthEnd = offset - currentChannel + Math.min(channels, currentChannel + depthRadius + 1);\n        var norm = 0;\n\n        for (var k = depthBegin; k < depthEnd; k++) {\n          norm += Math.pow(inputImageValues[k], 2);\n        }\n\n        norm = alpha * norm + bias;\n\n        for (var _k = depthBegin; _k < depthEnd; _k++) {\n          var dyi = -2 * alpha * beta * inputImageValues[_k] * outputImageValues[offset] / norm;\n\n          if (offset === _k) {\n            dyi += Math.pow(norm, -beta);\n          }\n\n          dyi *= dyValues[offset];\n          result[_k] += dyi;\n        }\n      }\n\n      return tf.tensor4d(result, dy.shape);\n    }\n  }, {\n    key: \"multinomial\",\n    value: function multinomial(logits, normalized, numSamples, seed) {\n      assertNotComplex(logits, 'multinomial');\n      var probabilities = normalized ? logits : tf.softmax(logits);\n      var batchSize = probabilities.shape[0];\n      var numEvents = probabilities.shape[1];\n      var res = tf.zeros([batchSize, numSamples], 'int32');\n      var resVals = this.readSync(res.dataId);\n      var probVals = this.readSync(probabilities.dataId);\n\n      for (var b = 0; b < batchSize; ++b) {\n        var offset = b * numEvents; // The cdf won't include the last event. It will be implicit if no other\n        // event happened.\n\n        var cdf = new Float32Array(numEvents - 1);\n        cdf[0] = probVals[offset];\n\n        for (var event = 1; event < cdf.length; ++event) {\n          cdf[event] = cdf[event - 1] + probVals[offset + event];\n        }\n\n        var random = seedrandom.alea(seed.toString());\n        var outOffset = b * numSamples;\n\n        for (var sampleId = 0; sampleId < numSamples; ++sampleId) {\n          var r = random(); // Assume last event happened by default.\n\n          resVals[outOffset + sampleId] = cdf.length;\n\n          for (var _event = 0; _event < cdf.length; _event++) {\n            if (r < cdf[_event]) {\n              resVals[outOffset + sampleId] = _event;\n              break;\n            }\n          }\n        }\n      }\n\n      return res;\n    }\n  }, {\n    key: \"oneHot\",\n    value: function oneHot(indices, depth, onValue, offValue) {\n      assertNotComplex(indices, 'oneHot');\n      var res = new Float32Array(indices.size * depth);\n      res.fill(offValue);\n      var indicesVal = this.readSync(indices.dataId);\n\n      for (var event = 0; event < indices.size; ++event) {\n        if (indicesVal[event] >= 0 && indicesVal[event] < depth) {\n          res[event * depth + indicesVal[event]] = onValue;\n        }\n      }\n\n      return tf.tensor2d(res, [indices.size, depth], 'int32');\n    }\n  }, {\n    key: \"nonMaxSuppression\",\n    value: function nonMaxSuppression(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {\n      assertNotComplex(boxes, 'nonMaxSuppression');\n      var boxesVals = this.readSync(boxes.dataId);\n      var scoresVals = this.readSync(scores.dataId);\n      return nonMaxSuppressionV3Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);\n    }\n  }, {\n    key: \"fft\",\n    value: function fft(x) {\n      return this.fftBatch(x, false);\n    }\n  }, {\n    key: \"ifft\",\n    value: function ifft(x) {\n      return this.fftBatch(x, true);\n    }\n    /**\n     * Calculate FFT of inner most elements of batch tensor.\n     */\n\n  }, {\n    key: \"fftBatch\",\n    value: function fftBatch(x, inverse) {\n      var batch = x.shape[0];\n      var innerDim = x.shape[1]; // Collects real and imaginary values separately.\n\n      var realResult = tf.buffer(x.shape, 'float32');\n      var imagResult = tf.buffer(x.shape, 'float32');\n      var real = tf.real(x).as2D(batch, innerDim);\n      var imag = tf.imag(x).as2D(batch, innerDim);\n\n      for (var b = 0; b < batch; b++) {\n        // TODO: Support slice ops for complex type.\n        var r = real.slice([b, 0], [1, innerDim]);\n        var i = imag.slice([b, 0], [1, innerDim]);\n        var input = tf.complex(r, i); // Run FFT by batch element.\n\n        var res = this.readSync(this.fftImpl(input, inverse).dataId);\n\n        for (var d = 0; d < innerDim; d++) {\n          var c = backend_util.getComplexWithIndex(res, d);\n          realResult.values[b * innerDim + d] = c.real;\n          imagResult.values[b * innerDim + d] = c.imag;\n        }\n      }\n\n      var t = tf.complex(realResult.toTensor(), imagResult.toTensor());\n      return t.as2D(batch, innerDim);\n    }\n  }, {\n    key: \"fftImpl\",\n    value: function fftImpl(x, inverse) {\n      var x1D = x.as1D();\n      var n = x1D.size;\n\n      if (this.isExponentOf2(n)) {\n        var result = this.fftRadix2(x1D, n, inverse).as2D(x.shape[0], x.shape[1]);\n\n        if (inverse) {\n          result = tf.complex(tf.real(result).div(tf.scalar(n)), tf.imag(result).div(tf.scalar(n)));\n        }\n\n        return result;\n      } else {\n        var data = this.readSync(x.dataId);\n        var rawOutput = this.fourierTransformByMatmul(data, n, inverse);\n        var output = backend_util.splitRealAndImagArrays(rawOutput);\n        return tf.complex(output.real, output.imag).as2D(x.shape[0], x.shape[1]);\n      }\n    }\n  }, {\n    key: \"isExponentOf2\",\n    value: function isExponentOf2(size) {\n      return (size & size - 1) === 0;\n    } // FFT using Cooley-Tukey algorithm on radix 2 dimensional input.\n\n  }, {\n    key: \"fftRadix2\",\n    value: function fftRadix2(input, size, inverse) {\n      if (size === 1) {\n        return input;\n      }\n\n      var data = this.readSync(input.dataId);\n      var half = size / 2;\n      var evenComplex = backend_util.complexWithEvenIndex(data);\n      var evenTensor = tf.complex(evenComplex.real, evenComplex.imag).as1D();\n      var oddComplex = backend_util.complexWithOddIndex(data);\n      var oddTensor = tf.complex(oddComplex.real, oddComplex.imag).as1D(); // Recursive call for half part of original input.\n\n      evenTensor = this.fftRadix2(evenTensor, half, inverse);\n      oddTensor = this.fftRadix2(oddTensor, half, inverse);\n      var e = backend_util.exponents(size, inverse);\n      var exponent = tf.complex(e.real, e.imag).mul(oddTensor);\n      var addPart = evenTensor.add(exponent);\n      var subPart = evenTensor.sub(exponent);\n      var realTensor = tf.real(addPart).concat(tf.real(subPart));\n      var imagTensor = tf.imag(addPart).concat(tf.imag(subPart));\n      return tf.complex(realTensor, imagTensor).as1D();\n    } // Calculate fourier transform by multplying sinusoid matrix.\n\n  }, {\n    key: \"fourierTransformByMatmul\",\n    value: function fourierTransformByMatmul(data, size, inverse) {\n      var ret = new Float32Array(size * 2); // TODO: Use matmul instead once it supports complex64 type.\n\n      for (var r = 0; r < size; r++) {\n        var real = 0.0;\n        var imag = 0.0;\n\n        for (var c = 0; c < size; c++) {\n          var e = backend_util.exponent(r * c, size, inverse);\n          var term = backend_util.getComplexWithIndex(data, c);\n          real += term.real * e.real - term.imag * e.imag;\n          imag += term.real * e.imag + term.imag * e.real;\n        }\n\n        if (inverse) {\n          real /= size;\n          imag /= size;\n        }\n\n        backend_util.assignToTypedArray(ret, real, imag, r);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"depthToSpace\",\n    value: function depthToSpace(x, blockSize, dataFormat) {\n      util.assert(dataFormat === 'NHWC', function () {\n        return \"Only NHWC dataFormat supported on CPU for depthToSpace. Got \".concat(dataFormat);\n      });\n      util.assert(blockSize > 1, function () {\n        return \"blockSize should be > 1 for depthToSpace, but was: \".concat(blockSize);\n      });\n      var batchSize = x.shape[0];\n      var inputHeight = x.shape[1];\n      var inputWidth = x.shape[2];\n      var inputDepth = x.shape[3];\n      var outputHeight = inputHeight * blockSize;\n      var outputWidth = inputWidth * blockSize;\n      var outputDepth = inputDepth / (blockSize * blockSize);\n      var xValues = this.readSync(x.dataId);\n      var result = new Float32Array(batchSize * outputHeight * outputWidth * outputDepth);\n      var outputIdx = 0;\n\n      for (var b = 0; b < batchSize; ++b) {\n        for (var h = 0; h < outputHeight; ++h) {\n          var inH = Math.floor(h / blockSize);\n          var offsetH = h % blockSize;\n\n          for (var w = 0; w < outputWidth; ++w) {\n            var inW = Math.floor(w / blockSize);\n            var offsetW = w % blockSize;\n            var offsetD = (offsetH * blockSize + offsetW) * outputDepth;\n\n            for (var d = 0; d < outputDepth; ++d) {\n              var inD = d + offsetD;\n              var inputIdx = inD + inputDepth * (inW + inputWidth * (inH + inputHeight * b));\n              result[outputIdx++] = xValues[inputIdx];\n            }\n          }\n        }\n      }\n\n      return tf.tensor4d(result, [batchSize, outputHeight, outputWidth, outputDepth]);\n    }\n  }, {\n    key: \"broadcastedBinaryOp\",\n    value: function broadcastedBinaryOp(a, b, dtype, op) {\n      var newShape = backend_util.assertAndGetBroadcastShape(a.shape, b.shape);\n      var result = tf.buffer(newShape, dtype);\n      var aVals = this.readSync(a.dataId);\n      var bVals = this.readSync(b.dataId);\n      var aBroadcastDims = backend_util.getBroadcastDims(a.shape, newShape);\n      var bBroadcastDims = backend_util.getBroadcastDims(b.shape, newShape);\n      var resVals = result.values;\n\n      if (aBroadcastDims.length + bBroadcastDims.length === 0) {\n        for (var i = 0; i < resVals.length; ++i) {\n          resVals[i] = op(aVals[i % aVals.length], bVals[i % bVals.length]);\n        }\n      } else {\n        var aBuf = this.bufferSync(a);\n        var bBuf = this.bufferSync(b);\n\n        var _loop2 = function _loop2(_i3) {\n          var loc = result.indexToLoc(_i3);\n          var aLoc = loc.slice(-a.rank);\n          aBroadcastDims.forEach(function (d) {\n            return aLoc[d] = 0;\n          });\n          var aIndex = aBuf.locToIndex(aLoc);\n          var bLoc = loc.slice(-b.rank);\n          bBroadcastDims.forEach(function (d) {\n            return bLoc[d] = 0;\n          });\n          var bIndex = bBuf.locToIndex(bLoc);\n          resVals[_i3] = op(aVals[aIndex], bVals[bIndex]);\n        };\n\n        for (var _i3 = 0; _i3 < resVals.length; ++_i3) {\n          _loop2(_i3);\n        }\n      }\n\n      return result.toTensor();\n    }\n  }, {\n    key: \"broadcastedBinaryComplexOp\",\n    value: function broadcastedBinaryComplexOp(a, b, op) {\n      var newShape = backend_util.assertAndGetBroadcastShape(a.shape, b.shape);\n      var realResult = tf.buffer(newShape, 'float32');\n      var imagResult = tf.buffer(newShape, 'float32');\n      var aVals = this.readSync(a.dataId);\n      var bVals = this.readSync(b.dataId);\n      var aBroadcastDims = backend_util.getBroadcastDims(a.shape, newShape);\n      var bBroadcastDims = backend_util.getBroadcastDims(b.shape, newShape);\n      var realVals = realResult.values;\n      var imagVals = imagResult.values;\n\n      if (aBroadcastDims.length + bBroadcastDims.length === 0) {\n        for (var i = 0; i < realVals.length; i++) {\n          var aIdx = i % aVals.length;\n          var bIdx = i % bVals.length;\n          var result = op(aVals[aIdx * 2], aVals[aIdx * 2 + 1], bVals[bIdx * 2], bVals[bIdx * 2 + 1]);\n          realVals[i] = result.real;\n          imagVals[i] = result.imag;\n        }\n      } else {\n        var aRealBuf = this.bufferSync(this.data.get(a.dataId).complexTensors.real);\n        var bRealBuf = this.bufferSync(this.data.get(b.dataId).complexTensors.real);\n\n        var _loop3 = function _loop3(_i4) {\n          var loc = realResult.indexToLoc(_i4);\n          var aLoc = loc.slice(-a.rank);\n          aBroadcastDims.forEach(function (d) {\n            return aLoc[d] = 0;\n          });\n          var aIndex = aRealBuf.locToIndex(aLoc);\n          var bLoc = loc.slice(-b.rank);\n          bBroadcastDims.forEach(function (d) {\n            return bLoc[d] = 0;\n          });\n          var bIndex = bRealBuf.locToIndex(bLoc);\n          var opResult = op(aVals[aIndex * 2], aVals[aIndex * 2 + 1], bVals[bIndex * 2], bVals[bIndex * 2 + 1]);\n          realVals[_i4] = opResult.real;\n          imagVals[_i4] = opResult.imag;\n        };\n\n        for (var _i4 = 0; _i4 < realVals.length; _i4++) {\n          _loop3(_i4);\n        }\n      }\n\n      return this.complex(realResult.toTensor(), imagResult.toTensor());\n    }\n  }, {\n    key: \"split\",\n    value: function split(x, sizeSplits, axis) {\n      return _split(x, sizeSplits, axis);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {}\n  }, {\n    key: \"floatPrecision\",\n    value: function floatPrecision() {\n      return 32;\n    }\n    /** Returns the smallest representable number.  */\n\n  }, {\n    key: \"epsilon\",\n    value: function epsilon() {\n      return _get(_getPrototypeOf(MathBackendCPU.prototype), \"epsilon\", this).call(this);\n    }\n  }, {\n    key: \"cropAndResize\",\n    value: function cropAndResize(images, boxes, boxIndex, cropSize, method, extrapolationValue) {\n      var _images$shape = _slicedToArray(images.shape, 4),\n          batch = _images$shape[0],\n          imageHeight = _images$shape[1],\n          imageWidth = _images$shape[2],\n          numChannels = _images$shape[3];\n\n      var numBoxes = boxes.shape[0];\n\n      var _cropSize = _slicedToArray(cropSize, 2),\n          cropHeight = _cropSize[0],\n          cropWidth = _cropSize[1];\n\n      var output = tf.buffer([numBoxes, cropHeight, cropWidth, numChannels], 'float32');\n      var boxVals = this.readSync(boxes.dataId);\n      var boxIndVals = this.readSync(boxIndex.dataId);\n      var imageVals = this.readSync(images.dataId);\n      var inStride = images.strides; // to calculate flat indexes into image\n\n      var outStride = output.strides; // to calculate flat indexes into output\n      // Reference implementation\n      // tslint:disable-next-line:max-line-length\n      // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op.cc\n\n      for (var b = 0; b < numBoxes; b++) {\n        var startInd = b * 4;\n        var y1 = boxVals[startInd];\n        var x1 = boxVals[startInd + 1];\n        var y2 = boxVals[startInd + 2];\n        var x2 = boxVals[startInd + 3];\n        var bInd = boxIndVals[b];\n\n        if (bInd >= batch) {\n          continue;\n        }\n\n        var heightScale = cropHeight > 1 ? (y2 - y1) * (imageHeight - 1) / (cropHeight - 1) : 0;\n        var widthScale = cropWidth > 1 ? (x2 - x1) * (imageWidth - 1) / (cropWidth - 1) : 0;\n\n        for (var y = 0; y < cropHeight; y++) {\n          var yInd = cropHeight > 1 ? y1 * (imageHeight - 1) + y * heightScale : 0.5 * (y1 + y2) * (imageHeight - 1);\n\n          if (yInd < 0 || yInd > imageHeight - 1) {\n            for (var x = 0; x < cropWidth; x++) {\n              for (var c = 0; c < numChannels; c++) {\n                var ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                output.values[ind] = extrapolationValue;\n              }\n            }\n\n            continue;\n          }\n\n          if (method === 'bilinear') {\n            var topInd = Math.floor(yInd);\n            var bottomInd = Math.ceil(yInd);\n            var yLerp = yInd - topInd;\n\n            for (var _x3 = 0; _x3 < cropWidth; _x3++) {\n              var xInd = cropWidth > 1 ? x1 * (imageWidth - 1) + _x3 * widthScale : 0.5 * (x1 + x2) * (imageWidth - 1);\n\n              if (xInd < 0 || xInd > imageWidth - 1) {\n                for (var _c = 0; _c < numChannels; _c++) {\n                  var _ind = _c + _x3 * outStride[2] + y * outStride[1] + b * outStride[0];\n\n                  output.values[_ind] = extrapolationValue;\n                }\n\n                continue;\n              }\n\n              var leftInd = Math.floor(xInd);\n              var rightInd = Math.ceil(xInd);\n              var xLerp = xInd - leftInd;\n\n              for (var _c2 = 0; _c2 < numChannels; _c2++) {\n                var _ind2 = _c2 + leftInd * inStride[2] + topInd * inStride[1] + bInd * inStride[0];\n\n                var topLeft = imageVals[_ind2];\n                _ind2 = _c2 + rightInd * inStride[2] + topInd * inStride[1] + bInd * inStride[0];\n                var topRight = imageVals[_ind2];\n                _ind2 = _c2 + leftInd * inStride[2] + bottomInd * inStride[1] + bInd * inStride[0];\n                var bottomLeft = imageVals[_ind2];\n                _ind2 = _c2 + rightInd * inStride[2] + bottomInd * inStride[1] + bInd * inStride[0];\n                var bottomRight = imageVals[_ind2];\n                var top = topLeft + (topRight - topLeft) * xLerp;\n                var bottom = bottomLeft + (bottomRight - bottomLeft) * xLerp;\n                _ind2 = _c2 + _x3 * outStride[2] + y * outStride[1] + b * outStride[0];\n                output.values[_ind2] = top + (bottom - top) * yLerp;\n              }\n            }\n          } else {\n            // method == \"nearest\"\n            for (var _x4 = 0; _x4 < cropWidth; ++_x4) {\n              var _xInd = cropWidth > 1 ? x1 * (imageWidth - 1) + _x4 * widthScale : 0.5 * (x1 + x2) * (imageWidth - 1);\n\n              if (_xInd < 0 || _xInd > imageWidth - 1) {\n                for (var _c3 = 0; _c3 < numChannels; _c3++) {\n                  var _ind3 = _c3 + _x4 * outStride[2] + y * outStride[1] + b * outStride[0];\n\n                  output.values[_ind3] = extrapolationValue;\n                }\n\n                continue;\n              }\n\n              var closestX = Math.round(_xInd);\n              var closestY = Math.round(yInd);\n\n              for (var _c4 = 0; _c4 < numChannels; _c4++) {\n                var inInd = _c4 + closestX * inStride[2] + closestY * inStride[1] + bInd * inStride[0];\n                var outInd = _c4 + _x4 * outStride[2] + y * outStride[1] + b * outStride[0];\n                output.values[outInd] = imageVals[inInd];\n              }\n            }\n          }\n        }\n      }\n\n      return output.toTensor();\n    }\n  }, {\n    key: \"sparseToDense\",\n    value: function sparseToDense(sparseIndices, sparseValues, outputShape, defaultValue) {\n      var _backend_util$calcula = backend_util.calculateShapes(sparseValues, sparseIndices, outputShape),\n          sliceRank = _backend_util$calcula.sliceRank,\n          numUpdates = _backend_util$calcula.numUpdates,\n          sliceSize = _backend_util$calcula.sliceSize,\n          strides = _backend_util$calcula.strides,\n          outputSize = _backend_util$calcula.outputSize;\n\n      var sumDupeIndices = false;\n      return this.scatter(sparseIndices, sparseValues, outputShape, outputSize, sliceSize, numUpdates, sliceRank, strides, defaultValue, sumDupeIndices);\n    }\n  }, {\n    key: \"gatherND\",\n    value: function gatherND(x, indices) {\n      var indicesShape = indices.shape;\n      var sliceRank = indicesShape[indicesShape.length - 1];\n\n      var _backend_util$prepare = backend_util.prepareAndValidate(x, indices),\n          _backend_util$prepare2 = _slicedToArray(_backend_util$prepare, 4),\n          resultShape = _backend_util$prepare2[0],\n          numSlices = _backend_util$prepare2[1],\n          sliceSize = _backend_util$prepare2[2],\n          strides = _backend_util$prepare2[3];\n\n      if (numSlices === 0) {\n        return tf.tensor([], resultShape, x.dtype);\n      }\n\n      var buffer = new TensorBuffer([numSlices, sliceSize], x.dtype);\n      var indicesData = this.readSync(indices.dataId);\n      var xData = this.readSync(x.dataId);\n\n      for (var i = 0; i < numSlices; i++) {\n        var index = [];\n        var flattenIndex = 0;\n\n        for (var j = 0; j < sliceRank; j++) {\n          var dim = indicesData[i * sliceRank + j];\n          flattenIndex += dim * strides[j];\n          index.push(dim);\n        }\n\n        if (flattenIndex < 0 || flattenIndex >= x.size / sliceSize) {\n          throw new Error(\"Invalid indices: \".concat(index, \" does not index into \").concat(x.shape));\n        }\n\n        for (var k = 0; k < sliceSize; k++) {\n          buffer.values[i * sliceSize + k] = xData[flattenIndex * sliceSize + k];\n        }\n      }\n\n      return buffer.toTensor().reshape(resultShape);\n    }\n  }, {\n    key: \"scatterND\",\n    value: function scatterND(indices, updates, shape) {\n      var _backend_util$calcula2 = backend_util.calculateShapes(updates, indices, shape),\n          sliceRank = _backend_util$calcula2.sliceRank,\n          numUpdates = _backend_util$calcula2.numUpdates,\n          sliceSize = _backend_util$calcula2.sliceSize,\n          strides = _backend_util$calcula2.strides,\n          outputSize = _backend_util$calcula2.outputSize;\n\n      var defaultValue = tf.scalar(0);\n      var sumDupeIndices = true;\n      return this.scatter(indices, updates, shape, outputSize, sliceSize, numUpdates, sliceRank, strides, defaultValue, sumDupeIndices);\n    }\n  }, {\n    key: \"fill\",\n    value: function fill(shape, value, dtype) {\n      dtype = dtype || util.inferDtype(value);\n      var values = util.getArrayFromDType(dtype, util.sizeFromShape(shape));\n      values.fill(value);\n      return engine().makeTensor(values, shape, dtype, this);\n    }\n  }, {\n    key: \"onesLike\",\n    value: function onesLike(x) {\n      if (x.dtype === 'string') {\n        throw new Error('onesLike is not supported for string tensors');\n      } else {\n        return this.fill(x.shape, 1, x.dtype);\n      }\n    }\n  }, {\n    key: \"zerosLike\",\n    value: function zerosLike(x) {\n      var values = util.getArrayFromDType(x.dtype, util.sizeFromShape(x.shape));\n      return this.makeOutput(values, x.shape, x.dtype);\n    }\n  }, {\n    key: \"linspace\",\n    value: function linspace(start, stop, num) {\n      return backend_util.linspaceImpl(start, stop, num);\n    }\n  }, {\n    key: \"scatter\",\n    value: function scatter(indices, updates, shape, outputSize, sliceSize, numUpdates, sliceRank, strides, defaultValue, sumDupeIndices) {\n      var flattenShape = [outputSize / sliceSize, sliceSize];\n      var indicesData = this.readSync(indices.dataId);\n      var updatesData = this.readSync(updates.dataId);\n\n      if (outputSize === 0) {\n        return tf.tensor([], shape, updates.dtype);\n      }\n\n      var buffer = new TensorBuffer(flattenShape, updates.dtype);\n      buffer.values.fill(this.readSync(defaultValue.dataId)[0]);\n\n      for (var i = 0; i < numUpdates; i++) {\n        var index = [];\n        var flattenIndex = 0;\n\n        for (var j = 0; j < sliceRank; j++) {\n          var dim = indicesData[i * sliceRank + j];\n          index.push(dim);\n          flattenIndex += dim * strides[j];\n        }\n\n        if (flattenIndex < 0 || flattenIndex >= outputSize / sliceSize) {\n          throw new Error(\"Invalid indices: \".concat(index, \" does not index into \").concat(shape));\n        }\n\n        for (var k = 0; k < sliceSize; k++) {\n          if (sumDupeIndices) {\n            buffer.values[flattenIndex * sliceSize + k] += updatesData[i * sliceSize + k];\n          } else {\n            buffer.values[flattenIndex * sliceSize + k] = updates.rank === 0 ? updatesData[0] : updatesData[i * sliceSize + k];\n          }\n        }\n      }\n\n      return buffer.toTensor().reshape(shape);\n    }\n  }]);\n\n  return MathBackendCPU;\n}(KernelBackend);","map":{"version":3,"sources":["../src/backend_cpu.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\nimport { backend_util, buffer, DataStorage, engine, env, kernel_impls, KernelBackend, max, slice_util, TensorBuffer, upcastType, util } from '@tensorflow/tfjs-core';\nconst nonMaxSuppressionV3Impl = kernel_impls.nonMaxSuppressionV3Impl;\nconst split = kernel_impls.split;\nconst tile = kernel_impls.tile;\nconst topkImpl = kernel_impls.topkImpl;\nconst whereImpl = kernel_impls.whereImpl;\nimport * as seedrandom from 'seedrandom';\nimport { assertNotComplex } from './cpu_util';\nimport { maxPoolPositions, pool } from './utils/pool_utils';\nfunction mapActivation(backend, x, activation, preluActivationWeights) {\n    if (activation === 'linear') {\n        return backend.linear(x);\n    }\n    else if (activation === 'relu') {\n        return backend.relu(x);\n    }\n    else if (activation === 'elu') {\n        return backend.elu(x);\n    }\n    else if (activation === 'relu6') {\n        return backend.relu6(x);\n    }\n    else if (activation === 'prelu') {\n        return backend.prelu(x, preluActivationWeights);\n    }\n    throw new Error(`Activation ${activation} has not been implemented for the CPU backend.`);\n}\nexport class MathBackendCPU extends KernelBackend {\n    constructor() {\n        super();\n        this.blockSize = 48;\n        this.firstUse = true;\n        this.data = new DataStorage(this, engine());\n    }\n    write(values, shape, dtype) {\n        if (this.firstUse) {\n            this.firstUse = false;\n            if (env().get('IS_NODE')) {\n                backend_util.warn('\\n============================\\n' +\n                    'Hi there ðŸ‘‹. Looks like you are running TensorFlow.js in ' +\n                    'Node.js. To speed things up dramatically, install our node ' +\n                    'backend, which binds to TensorFlow C++, by running ' +\n                    'npm i @tensorflow/tfjs-node, ' +\n                    'or npm i @tensorflow/tfjs-node-gpu if you have CUDA. ' +\n                    'Then call require(\\'@tensorflow/tfjs-node\\'); (-gpu ' +\n                    'suffix for CUDA) at the start of your program. ' +\n                    'Visit https://github.com/tensorflow/tfjs-node for more details.' +\n                    '\\n============================');\n            }\n        }\n        const dataId = {};\n        this.data.set(dataId, { values, dtype, refCount: 1 });\n        return dataId;\n    }\n    /** Increase refCount of a `TensorData`. */\n    incRef(dataId) {\n        const tensorData = this.data.get(dataId);\n        tensorData.refCount++;\n    }\n    /** Decrease refCount of a `TensorData`. */\n    decRef(dataId) {\n        if (this.data.has(dataId)) {\n            const tensorData = this.data.get(dataId);\n            tensorData.refCount--;\n        }\n    }\n    move(dataId, values, shape, dtype) {\n        this.data.set(dataId, { values, dtype, refCount: 1 });\n    }\n    numDataIds() {\n        return this.data.numDataIds();\n    }\n    async read(dataId) {\n        return this.readSync(dataId);\n    }\n    readSync(dataId) {\n        const { dtype, complexTensors } = this.data.get(dataId);\n        if (dtype === 'complex64') {\n            const realValues = this.readSync(complexTensors.real.dataId);\n            const imagValues = this.readSync(complexTensors.imag.dataId);\n            return backend_util.mergeRealAndImagArrays(realValues, imagValues);\n        }\n        return this.data.get(dataId).values;\n    }\n    bufferSync(t) {\n        const data = this.readSync(t.dataId);\n        let decodedData = data;\n        if (t.dtype === 'string') {\n            try {\n                // Decode the bytes into string.\n                decodedData = data.map(d => util.decodeString(d));\n            }\n            catch (_a) {\n                throw new Error('Failed to decode encoded string bytes into utf-8');\n            }\n        }\n        return tf.buffer(t.shape, t.dtype, decodedData);\n    }\n    makeOutput(values, shape, dtype) {\n        const dataId = this.write(values, shape, dtype);\n        return engine().makeTensorFromDataId(dataId, shape, dtype, this);\n    }\n    disposeData(dataId) {\n        if (this.data.has(dataId)) {\n            const { complexTensors } = this.data.get(dataId);\n            if (complexTensors != null) {\n                complexTensors.real.dispose();\n                complexTensors.imag.dispose();\n            }\n            this.data.delete(dataId);\n        }\n    }\n    disposeIntermediateTensorInfo(tensorInfo) {\n        const dataId = tensorInfo.dataId;\n        if (this.data.has(dataId)) {\n            const tensorData = this.data.get(dataId);\n            tensorData.refCount--;\n            if (tensorData.refCount < 1) {\n                this.disposeData(dataId);\n            }\n        }\n    }\n    async time(f) {\n        const start = util.now();\n        f();\n        const kernelMs = util.now() - start;\n        return { kernelMs };\n    }\n    memory() {\n        return {\n            // Unreliable due to automatic gc. The numbers above are cumulative.\n            unreliable: true,\n            reasons: ['The reported memory is an upper bound. Due to automatic garbage ' +\n                    'collection, the true allocated memory may be less.']\n        };\n    }\n    complex(real, imag) {\n        const result = this.makeOutput(null, real.shape, 'complex64');\n        const resultData = this.data.get(result.dataId);\n        // The backend owns the reference to the underlying real and imaginary\n        // clones. These will explicitly get disposed when the complex tensor is\n        // disposed.\n        resultData.complexTensors = {\n            real: engine().keep(real.clone()),\n            imag: engine().keep(imag.clone())\n        };\n        return result;\n    }\n    real(input) {\n        const resultData = this.data.get(input.dataId);\n        return resultData.complexTensors.real.clone();\n    }\n    imag(input) {\n        const resultData = this.data.get(input.dataId);\n        return resultData.complexTensors.imag.clone();\n    }\n    slice(x, begin, size) {\n        assertNotComplex(x, 'slice');\n        const isContinous = slice_util.isSliceContinous(x.shape, begin, size);\n        if (isContinous) {\n            const flatOffset = slice_util.computeFlatOffset(begin, x.strides);\n            const length = util.sizeFromShape(size);\n            const vals = this.readSync(x.dataId);\n            return tf.tensor(vals.subarray(flatOffset, flatOffset + length), size, x.dtype);\n        }\n        const buffer = tf.buffer(size, x.dtype);\n        const xBuf = this.bufferSync(x);\n        for (let i = 0; i < buffer.size; ++i) {\n            const loc = buffer.indexToLoc(i);\n            const xLoc = loc.map((idx, j) => idx + begin[j]);\n            buffer.values[i] = xBuf.get(...xLoc);\n        }\n        return buffer.toTensor();\n    }\n    stridedSlice(x, begin, end, strides) {\n        assertNotComplex(x, 'stridedSlice');\n        const outShape = slice_util.computeOutShape(begin, end, strides);\n        if (outShape.some(axis => axis === 0)) {\n            return tf.tensor([], outShape);\n        }\n        const buffer = tf.buffer(outShape, x.dtype);\n        const xBuf = this.bufferSync(x);\n        for (let i = 0; i < buffer.size; i++) {\n            const loc = buffer.indexToLoc(i);\n            const newLoc = new Array(loc.length);\n            for (let j = 0; j < newLoc.length; j++) {\n                newLoc[j] = loc[j] * strides[j] + begin[j];\n            }\n            buffer.set(xBuf.get(...newLoc), ...loc);\n        }\n        return buffer.toTensor();\n    }\n    diag(x) {\n        const xVals = this.readSync(x.dataId);\n        const buffer = tf.buffer([x.size, x.size], x.dtype);\n        const vals = buffer.values;\n        for (let i = 0; i < xVals.length; i++) {\n            vals[i * x.size + i] = xVals[i];\n        }\n        return buffer.toTensor();\n    }\n    unstack(x, axis) {\n        const num = x.shape[axis];\n        const outShape = new Array(x.rank - 1);\n        let outIndex = 0;\n        for (let i = 0; i < x.rank; i++) {\n            if (i !== axis) {\n                outShape[outIndex++] = x.shape[i];\n            }\n        }\n        const begin = new Array(x.rank).fill(0);\n        const size = x.shape.slice();\n        size[axis] = 1;\n        const res = new Array(num);\n        for (let i = 0; i < res.length; i++) {\n            begin[axis] = i;\n            res[i] = this.slice(x, begin, size).reshape(outShape);\n        }\n        return res;\n    }\n    reverse(x, axis) {\n        assertNotComplex(x, 'reverse');\n        const buffer = tf.buffer(x.shape, x.dtype);\n        const xBuf = this.bufferSync(x);\n        for (let i = 0; i < buffer.size; i++) {\n            const outLoc = buffer.indexToLoc(i);\n            const inLoc = outLoc.slice();\n            axis.forEach(ax => inLoc[ax] = x.shape[ax] - 1 - inLoc[ax]);\n            buffer.set(xBuf.get(...inLoc), ...outLoc);\n        }\n        return buffer.toTensor();\n    }\n    concat(tensors, axis) {\n        if (tensors[0].dtype === 'complex64') {\n            const reals = tensors.map((t) => tf.real(t));\n            const imags = tensors.map((t) => tf.imag(t));\n            return tf.complex(this.concat(reals, axis), this.concat(imags, axis));\n        }\n        const tensors2D = tensors.map(t => {\n            const innerSize = util.sizeFromShape(t.shape.slice(axis));\n            return t.as2D(-1, innerSize);\n        });\n        const outShape = backend_util.computeOutShape(tensors2D.map(t => t.shape), 1 /* axis\n          */);\n        const values = tf.buffer(outShape, tensors[0].dtype)\n            .values;\n        if (tensors2D[0].shape[0] === 1) {\n            // Use built-in TypedArray.set() method for speed.\n            let offset = 0;\n            tensors2D.forEach(t => {\n                values.set(this.readSync(t.dataId), offset);\n                offset += t.size;\n            });\n        }\n        else {\n            let colOffset = 0;\n            tensors2D.forEach(t => {\n                const tVals = this.readSync(t.dataId);\n                let tIdx = 0;\n                for (let row = 0; row < t.shape[0]; ++row) {\n                    const resIdx = row * outShape[1] + colOffset;\n                    for (let col = 0; col < t.shape[1]; ++col) {\n                        values[resIdx + col] = tVals[tIdx++];\n                    }\n                }\n                colOffset += t.shape[1];\n            });\n        }\n        const finalOutShape = backend_util.computeOutShape(tensors.map(t => t.shape), axis);\n        return tf.tensor(values, finalOutShape, tensors[0].dtype);\n    }\n    neg(x) {\n        assertNotComplex(x, 'neg');\n        return this.multiply(tf.scalar(-1), x);\n    }\n    add(a, b) {\n        if (a.dtype === 'complex64' || b.dtype === 'complex64') {\n            return this.broadcastedBinaryComplexOp(a.cast('complex64'), b.cast('complex64'), (aReal, aImag, bReal, bImag) => {\n                return { real: aReal + bReal, imag: aImag + bImag };\n            });\n        }\n        return this.broadcastedBinaryOp(a, b, upcastType(a.dtype, b.dtype), (aValue, bValue) => aValue + bValue);\n    }\n    addN(tensors) {\n        assertNotComplex(tensors, 'addN');\n        const vals = tensors.map(t => this.readSync(t.dataId));\n        const result = tf.buffer(tensors[0].shape, tensors[0].dtype);\n        const resultVals = result.values;\n        for (let i = 0; i < tensors.length; i++) {\n            const currVals = vals[i];\n            for (let j = 0; j < resultVals.length; j++) {\n                resultVals[j] += currVals[j];\n            }\n        }\n        return result.toTensor();\n    }\n    softmax(logits, dim) {\n        const axes = util.parseAxisParam([dim], logits.shape);\n        // TODO(annxingyuan): Call maxImpl rather than op as part of softmax kernel\n        // modularization.\n        const maxLogit = max(logits, axes);\n        const expandedShape = backend_util.expandShapeToKeepDim(maxLogit.shape, axes);\n        const a = this.subtract(logits, maxLogit.reshape(expandedShape));\n        const b = this.exp(a);\n        const sumExp = this.sum(b, axes).reshape(expandedShape);\n        // TODO(annxingyuan): Call divImpl rather than op as part of softmax\n        // kernel modularization.\n        return tf.div(b, sumExp);\n    }\n    subtract(a, b) {\n        if (a.dtype === 'complex64' || b.dtype === 'complex64') {\n            return this.broadcastedBinaryComplexOp(a.cast('complex64'), b.cast('complex64'), (aReal, aImag, bReal, bImag) => {\n                return { real: aReal - bReal, imag: aImag - bImag };\n            });\n        }\n        return this.broadcastedBinaryOp(a, b, upcastType(a.dtype, b.dtype), (aValue, bValue) => aValue - bValue);\n    }\n    pow(a, b) {\n        assertNotComplex([a, b], 'pow');\n        return this.broadcastedBinaryOp(a, b, a.dtype, (aValue, bValue) => Math.pow(aValue, bValue));\n    }\n    batchMatMul(a, b, transposeA, transposeB) {\n        assertNotComplex([a, b], 'matMul');\n        const sharedDim = transposeA ? a.shape[1] : a.shape[2];\n        const leftDim = transposeA ? a.shape[2] : a.shape[1];\n        const rightDim = transposeB ? b.shape[1] : b.shape[2];\n        const batchDim = a.shape[0];\n        const aValues = this.readSync(a.dataId);\n        const bValues = this.readSync(b.dataId);\n        const [aBatch, aOuterStep, aInnerStep] = transposeA ?\n            [a.strides[0], 1, a.strides[1]] :\n            [a.strides[0], a.strides[1], 1];\n        const [bInnerStep, bOuterStep, bBatch] = transposeB ?\n            [1, b.strides[1], b.strides[0]] :\n            [b.strides[1], 1, b.strides[0]];\n        const size = leftDim * rightDim;\n        const result = tf.buffer([batchDim, leftDim, rightDim], a.dtype);\n        const resVals = result.values;\n        const blockSize = this.blockSize;\n        for (let b = 0; b < batchDim; b++) {\n            for (let i0 = 0; i0 < leftDim; i0 += blockSize) {\n                for (let j0 = 0; j0 < rightDim; j0 += blockSize) {\n                    for (let k0 = 0; k0 < sharedDim; k0 += blockSize) {\n                        // for when blockSize doesn't evenly divide the input\n                        const iBlock = Math.min(i0 + blockSize, leftDim);\n                        const jBlock = Math.min(j0 + blockSize, rightDim);\n                        const kBlock = Math.min(k0 + blockSize, sharedDim);\n                        for (let i = i0; i < iBlock; i++) {\n                            for (let j = j0; j < jBlock; j++) {\n                                let sum = 0.0;\n                                for (let k = k0; k < kBlock; k++) {\n                                    sum += aValues[b * aBatch + i * aOuterStep + k * aInnerStep] *\n                                        bValues[k * bInnerStep + j * bOuterStep + b * bBatch];\n                                }\n                                resVals[b * size + (i * rightDim + j)] += sum;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result.toTensor();\n    }\n    fusedBatchMatMul({ a, b, transposeA, transposeB, bias, activation, preluActivationWeights }) {\n        let result = this.batchMatMul(a, b, transposeA, transposeB);\n        if (bias) {\n            result = this.add(result, bias);\n        }\n        if (activation) {\n            result =\n                mapActivation(this, result, activation, preluActivationWeights);\n        }\n        return result;\n    }\n    multiply(a, b) {\n        if (a.dtype === 'complex64' || b.dtype === 'complex64') {\n            return this.broadcastedBinaryComplexOp(a.cast('complex64'), b.cast('complex64'), (aReal, aImag, bReal, bImag) => {\n                return {\n                    real: aReal * bReal - aImag * bImag,\n                    imag: aReal * bImag + aImag * bReal\n                };\n            });\n        }\n        return this.broadcastedBinaryOp(a, b, upcastType(a.dtype, b.dtype), (aValue, bValue) => aValue * bValue);\n    }\n    floorDiv(a, b) {\n        assertNotComplex([a, b], 'floorDiv');\n        const op = (a, b) => Math.floor(a / b);\n        const outputDtype = 'int32';\n        return this.broadcastedBinaryOp(a, b, outputDtype, op);\n    }\n    sum(x, axes) {\n        assertNotComplex(x, 'sum');\n        backend_util.assertAxesAreInnerMostDims('sum', axes, x.rank);\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const resultDtype = upcastType(x.dtype, 'int32');\n        const result = tf.zeros(outShape, resultDtype);\n        const reduceSize = util.sizeFromShape(reduceShape);\n        const vals = this.readSync(result.dataId);\n        const aVals = this.readSync(x.dataId);\n        for (let i = 0; i < vals.length; ++i) {\n            const offset = i * reduceSize;\n            let sum = 0;\n            for (let j = 0; j < reduceSize; ++j) {\n                sum += aVals[offset + j];\n            }\n            vals[i] = sum;\n        }\n        return result;\n    }\n    prod(x, axes) {\n        assertNotComplex(x, 'sum');\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const resultDtype = upcastType(x.dtype, 'int32');\n        const result = tf.zeros(outShape, resultDtype);\n        const reduceSize = util.sizeFromShape(reduceShape);\n        const vals = this.readSync(result.dataId);\n        const aVals = this.readSync(x.dataId);\n        for (let i = 0; i < vals.length; ++i) {\n            const offset = i * reduceSize;\n            let prod = 1;\n            for (let j = 0; j < reduceSize; ++j) {\n                prod *= aVals[offset + j];\n            }\n            vals[i] = prod;\n        }\n        return result;\n    }\n    unsortedSegmentSum(x, segmentIds, numSegments) {\n        assertNotComplex(x, 'unsortedSegmentSum');\n        const res = [];\n        // Reshape the segment id's so that they can be broadcast with\n        // x. The new shape should be [segmentIds.shape, 1, ..., 1]\n        const numIters = x.rank - segmentIds.rank;\n        for (let i = 0; i < numIters; ++i) {\n            segmentIds = segmentIds.expandDims(i + 1);\n        }\n        for (let i = 0; i < numSegments; ++i) {\n            const segmentId = tf.scalar(i, 'int32');\n            const mask = tf.equal(segmentId, segmentIds).asType('float32');\n            const sum = mask.mul(x).sum(0);\n            res.push(sum);\n        }\n        return tf.stack(res);\n    }\n    argMin(x, axis) {\n        assertNotComplex(x, 'argMin');\n        const axes = [axis];\n        backend_util.assertAxesAreInnerMostDims('argMin', axes, x.rank);\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const result = tf.zeros(outShape, 'int32');\n        const reduceSize = util.sizeFromShape(reduceShape);\n        const vals = this.readSync(result.dataId);\n        const aVals = this.readSync(x.dataId);\n        for (let i = 0; i < vals.length; ++i) {\n            const offset = i * reduceSize;\n            let min = aVals[offset];\n            let minIndex = 0;\n            for (let j = 0; j < reduceSize; ++j) {\n                const value = aVals[offset + j];\n                if (value < min) {\n                    min = value;\n                    minIndex = j;\n                }\n            }\n            vals[i] = minIndex;\n        }\n        return result;\n    }\n    argMax(x, axis) {\n        assertNotComplex(x, 'argMax');\n        const axes = [axis];\n        backend_util.assertAxesAreInnerMostDims('argMax', axes, x.rank);\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const result = tf.zeros(outShape, 'int32');\n        const reduceSize = util.sizeFromShape(reduceShape);\n        const vals = this.readSync(result.dataId);\n        const aVals = this.readSync(x.dataId);\n        for (let i = 0; i < vals.length; ++i) {\n            const offset = i * reduceSize;\n            let max = aVals[offset];\n            let maxIndex = 0;\n            for (let j = 0; j < reduceSize; ++j) {\n                const value = aVals[offset + j];\n                if (value > max) {\n                    max = value;\n                    maxIndex = j;\n                }\n            }\n            vals[i] = maxIndex;\n        }\n        return result;\n    }\n    cumsum(x, axis, exclusive, reverse) {\n        assertNotComplex(x, 'cumsum');\n        if (axis !== x.rank - 1) {\n            throw new Error(`backend.cumsum in CPU expects an inner-most axis=${x.rank - 1} ` +\n                `but got axis=${axis}`);\n        }\n        const resultDtype = upcastType(x.dtype, 'int32');\n        const result = tf.zeros(x.shape, resultDtype);\n        const vals = this.readSync(result.dataId);\n        const aVals = this.readSync(x.dataId);\n        const finalDim = x.shape[x.rank - 1];\n        const indexAdjuster = reverse ?\n            (i, j) => i + finalDim - j - 1 :\n            (i, j) => i + j;\n        for (let i = 0; i < aVals.length; i += finalDim) {\n            for (let j = 0; j < finalDim; j++) {\n                const idx = indexAdjuster(i, j);\n                if (j === 0) {\n                    vals[idx] = exclusive ? 0 : aVals[idx];\n                }\n                else {\n                    const prevIdx = indexAdjuster(i, j - 1);\n                    vals[idx] = exclusive ? aVals[prevIdx] + vals[prevIdx] :\n                        aVals[idx] + vals[prevIdx];\n                }\n            }\n        }\n        return result;\n    }\n    equal(a, b) {\n        assertNotComplex([a, b], 'equal');\n        return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n            return (aVal === bVal) ? 1 : 0;\n        });\n    }\n    notEqual(a, b) {\n        assertNotComplex([a, b], 'notEqual');\n        return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n            return (aVal !== bVal) ? 1 : 0;\n        });\n    }\n    less(a, b) {\n        assertNotComplex([a, b], 'less');\n        return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n            return (aVal < bVal) ? 1 : 0;\n        });\n    }\n    lessEqual(a, b) {\n        assertNotComplex([a, b], 'lessEqual');\n        return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n            return (aVal <= bVal) ? 1 : 0;\n        });\n    }\n    greater(a, b) {\n        assertNotComplex([a, b], 'greater');\n        return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n            return (aVal > bVal) ? 1 : 0;\n        });\n    }\n    greaterEqual(a, b) {\n        assertNotComplex([a, b], 'greaterEqual');\n        return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n            return (aVal >= bVal) ? 1 : 0;\n        });\n    }\n    logicalNot(x) {\n        assertNotComplex(x, 'logicalNot');\n        const values = this.readSync(x.dataId);\n        const newValues = new Uint8Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            newValues[i] = values[i] ? 0 : 1;\n        }\n        return this.makeOutput(newValues, x.shape, 'bool');\n    }\n    logicalAnd(a, b) {\n        assertNotComplex([a, b], 'logicalAnd');\n        return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n            return aVal && bVal;\n        });\n    }\n    logicalOr(a, b) {\n        assertNotComplex([a, b], 'logicalOr');\n        return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n            return aVal || bVal;\n        });\n    }\n    select(condition, a, b) {\n        assertNotComplex([condition, a, b], 'select');\n        const values = this.readSync(condition.dataId);\n        const aValues = this.readSync(a.dataId);\n        const bValues = this.readSync(b.dataId);\n        const result = tf.zeros(a.shape, upcastType(a.dtype, b.dtype));\n        const newValues = this.readSync(result.dataId);\n        let index = 0;\n        const offset = condition.rank === 0 || condition.rank > 1 || a.rank === 1 ?\n            1 :\n            util.sizeFromShape(a.shape.slice(1));\n        for (let i = 0; i < values.length; i++) {\n            for (let j = 0; j < offset; j++) {\n                if (values[i] === 1) {\n                    newValues[index++] = aValues[i];\n                }\n                else {\n                    newValues[index++] = bValues[i];\n                }\n            }\n        }\n        return result;\n    }\n    where(condition) {\n        assertNotComplex([condition], 'where');\n        const condVals = this.readSync(condition.dataId);\n        return whereImpl(condition.shape, condVals);\n    }\n    topk(x, k, sorted) {\n        assertNotComplex(x, 'topk');\n        const xVals = this.readSync(x.dataId);\n        return topkImpl(xVals, x.shape, x.dtype, k, sorted);\n    }\n    min(x, axes) {\n        assertNotComplex(x, 'min');\n        backend_util.assertAxesAreInnerMostDims('min', axes, x.rank);\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const result = tf.zeros(outShape, x.dtype);\n        const reduceSize = util.sizeFromShape(reduceShape);\n        const vals = this.readSync(result.dataId);\n        const aVals = this.readSync(x.dataId);\n        for (let i = 0; i < vals.length; ++i) {\n            const offset = i * reduceSize;\n            let min = aVals[offset];\n            for (let j = 0; j < reduceSize; ++j) {\n                const value = aVals[offset + j];\n                if (value < min) {\n                    min = value;\n                }\n            }\n            vals[i] = min;\n        }\n        return result;\n    }\n    minimum(a, b) {\n        assertNotComplex([a, b], 'minimum');\n        return this.broadcastedBinaryOp(a, b, a.dtype, (aVal, bVal) => Math.min(aVal, bVal));\n    }\n    mod(a, b) {\n        assertNotComplex([a, b], 'mod');\n        return this.broadcastedBinaryOp(a, b, a.dtype, (aVal, bVal) => {\n            const rem = aVal % bVal;\n            if ((aVal < 0 && bVal < 0) || (aVal >= 0 && bVal >= 0)) {\n                return rem;\n            }\n            else {\n                return (rem + bVal) % bVal;\n            }\n        });\n    }\n    maximum(a, b) {\n        assertNotComplex([a, b], 'maximum');\n        return this.broadcastedBinaryOp(a, b, a.dtype, (aVal, bVal) => Math.max(aVal, bVal));\n    }\n    all(x, axes) {\n        assertNotComplex(x, 'all');\n        backend_util.assertAxesAreInnerMostDims('all', axes, x.rank);\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const result = tf.zeros(outShape, x.dtype);\n        const reduceSize = util.sizeFromShape(reduceShape);\n        const vals = this.readSync(result.dataId);\n        const aVals = this.readSync(x.dataId);\n        for (let i = 0; i < vals.length; ++i) {\n            const offset = i * reduceSize;\n            let all = aVals[offset];\n            for (let j = 0; j < reduceSize; ++j) {\n                const value = aVals[offset + j];\n                all = all && value;\n            }\n            vals[i] = all;\n        }\n        return result;\n    }\n    any(x, axes) {\n        assertNotComplex(x, 'any');\n        backend_util.assertAxesAreInnerMostDims('any', axes, x.rank);\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const result = tf.zeros(outShape, x.dtype);\n        const reduceSize = util.sizeFromShape(reduceShape);\n        const vals = this.readSync(result.dataId);\n        const aVals = this.readSync(x.dataId);\n        for (let i = 0; i < vals.length; ++i) {\n            const offset = i * reduceSize;\n            let anyVal = aVals[offset];\n            for (let j = 0; j < reduceSize; ++j) {\n                const value = aVals[offset + j];\n                anyVal = anyVal || value;\n            }\n            vals[i] = anyVal;\n        }\n        return result;\n    }\n    squaredDifference(a, b) {\n        assertNotComplex([a, b], 'squaredDifference');\n        return this.broadcastedBinaryOp(a, b, a.dtype, (aVal, bVal) => {\n            const diff = aVal - bVal;\n            return diff * diff;\n        });\n    }\n    ceil(x) {\n        assertNotComplex(x, 'ceil');\n        const values = this.readSync(x.dataId);\n        const newValues = new Float32Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            newValues[i] = Math.ceil(values[i]);\n        }\n        return this.makeOutput(newValues, x.shape, 'float32');\n    }\n    floor(x) {\n        assertNotComplex(x, 'floor');\n        const values = this.readSync(x.dataId);\n        const newValues = new Float32Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            newValues[i] = Math.floor(values[i]);\n        }\n        return this.makeOutput(newValues, x.shape, 'float32');\n    }\n    sign(x) {\n        assertNotComplex(x, 'x');\n        const values = this.readSync(x.dataId);\n        const newValues = new Float32Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            if (values[i] < 0) {\n                newValues[i] = -1;\n            }\n            else if (values[i] > 0) {\n                newValues[i] = 1;\n            }\n            else {\n                newValues[i] = 0;\n            }\n        }\n        return this.makeOutput(newValues, x.shape, 'float32');\n    }\n    isNaN(x) {\n        assertNotComplex(x, 'x');\n        const values = this.readSync(x.dataId);\n        const newValues = new Uint8Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            if (Number.isNaN(values[i])) {\n                newValues[i] = 1;\n            }\n        }\n        return this.makeOutput(newValues, x.shape, 'bool');\n    }\n    isInf(x) {\n        assertNotComplex(x, 'x');\n        const values = this.readSync(x.dataId);\n        const newValues = new Uint8Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            if (Math.abs(values[i]) === Infinity) {\n                newValues[i] = 1;\n            }\n        }\n        return this.makeOutput(newValues, x.shape, 'bool');\n    }\n    isFinite(x) {\n        assertNotComplex(x, 'x');\n        const values = this.readSync(x.dataId);\n        const newValues = new Uint8Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            if (Number.isFinite(values[i])) {\n                newValues[i] = 1;\n            }\n        }\n        return this.makeOutput(newValues, x.shape, 'bool');\n    }\n    round(x) {\n        assertNotComplex(x, 'round');\n        const values = this.readSync(x.dataId);\n        const newValues = new Float32Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            // The algorithm is based on banker's rounding.\n            const base = Math.floor(values[i]);\n            if (values[i] - base < 0.5) {\n                newValues[i] = Math.floor(values[i]);\n            }\n            else if (values[i] - base > 0.5) {\n                newValues[i] = Math.ceil(values[i]);\n            }\n            else {\n                if (base % 2.0 === 0.0) {\n                    newValues[i] = base;\n                }\n                else {\n                    newValues[i] = base + 1.0;\n                }\n            }\n        }\n        return this.makeOutput(newValues, x.shape, 'float32');\n    }\n    exp(x) {\n        assertNotComplex(x, 'exp');\n        const values = this.readSync(x.dataId);\n        const newValues = new Float32Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            newValues[i] = Math.exp(values[i]);\n        }\n        return this.makeOutput(newValues, x.shape, 'float32');\n    }\n    expm1(x) {\n        assertNotComplex(x, 'expm1');\n        const values = this.readSync(x.dataId);\n        const newValues = new Float32Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            newValues[i] = Math.expm1(values[i]);\n        }\n        return this.makeOutput(newValues, x.shape, 'float32');\n    }\n    log(x) {\n        assertNotComplex(x, 'log');\n        const values = this.readSync(x.dataId);\n        const newValues = new Float32Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            const value = values[i];\n            newValues[i] = Math.log(value);\n        }\n        return this.makeOutput(newValues, x.shape, 'float32');\n    }\n    log1p(x) {\n        assertNotComplex(x, 'log1p');\n        const values = this.readSync(x.dataId);\n        const newValues = new Float32Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            const value = values[i];\n            newValues[i] = Math.log1p(value);\n        }\n        return this.makeOutput(newValues, x.shape, 'float32');\n    }\n    sqrt(x) {\n        assertNotComplex(x, 'sqrt');\n        const values = this.readSync(x.dataId);\n        const newValues = new Float32Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            const value = values[i];\n            newValues[i] = Math.sqrt(value);\n        }\n        return this.makeOutput(newValues, x.shape, 'float32');\n    }\n    rsqrt(x) {\n        assertNotComplex(x, 'rsqrt');\n        const values = this.readSync(x.dataId);\n        const newValues = new Float32Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            const value = values[i];\n            newValues[i] = 1 / Math.sqrt(value);\n        }\n        return this.makeOutput(newValues, x.shape, 'float32');\n    }\n    reciprocal(x) {\n        assertNotComplex(x, 'reciprocal');\n        const values = this.readSync(x.dataId);\n        const newValues = new Float32Array(values.length);\n        for (let i = 0; i < values.length; ++i) {\n            newValues[i] = 1 / values[i];\n        }\n        return this.makeOutput(newValues, x.shape, 'float32');\n    }\n    linear(x) {\n        return x;\n    }\n    relu(x) {\n        assertNotComplex(x, 'relu');\n        const res = tf.zeros(x.shape, x.dtype);\n        const resVals = this.readSync(res.dataId);\n        const inVals = this.readSync(x.dataId);\n        for (let i = 0; i < inVals.length; ++i) {\n            resVals[i] = Math.max(0, inVals[i]);\n        }\n        return res;\n    }\n    relu6(x) {\n        assertNotComplex(x, 'relu');\n        const res = tf.zeros(x.shape, x.dtype);\n        const resVals = this.readSync(res.dataId);\n        const inVals = this.readSync(x.dataId);\n        for (let i = 0; i < inVals.length; ++i) {\n            resVals[i] = Math.min(Math.max(0, inVals[i]), 6);\n        }\n        return res;\n    }\n    prelu(x, a) {\n        assertNotComplex([x, a], 'prelu');\n        return this.broadcastedBinaryOp(x, a, x.dtype, (xValue, aValue) => xValue < 0 ? aValue * xValue : xValue);\n    }\n    elu(x) {\n        assertNotComplex(x, 'elu');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            const v = values[i];\n            if (v >= 0) {\n                resultValues[i] = v;\n            }\n            else {\n                resultValues[i] = (Math.exp(v) - 1);\n            }\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    eluDer(dy, y) {\n        assertNotComplex([dy, y], 'eluDer');\n        const resultValues = new Float32Array(y.size);\n        const values = this.readSync(y.dataId);\n        const dyValues = this.readSync(dy.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            const v = values[i];\n            if (v >= 1) {\n                resultValues[i] = dyValues[i];\n            }\n            else {\n                resultValues[i] = dyValues[i] * (v + 1);\n            }\n        }\n        return this.makeOutput(resultValues, y.shape, 'float32');\n    }\n    selu(x) {\n        assertNotComplex(x, 'selu');\n        // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n        // see: https://arxiv.org/abs/1706.02515\n        const scaleAlpha = backend_util.SELU_SCALEALPHA;\n        const scale = backend_util.SELU_SCALE;\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            const v = values[i];\n            if (v >= 0) {\n                resultValues[i] = scale * v;\n            }\n            else {\n                resultValues[i] = scaleAlpha * (Math.exp(v) - 1);\n            }\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    clip(x, min, max) {\n        assertNotComplex(x, 'clip');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            const v = values[i];\n            resultValues[i] = v > max ? max : (v < min ? min : v);\n        }\n        return this.makeOutput(resultValues, x.shape, x.dtype);\n    }\n    abs(x) {\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.abs(values[i]);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    complexAbs(x) {\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < x.size; ++i) {\n            const real = values[i * 2];\n            const imag = values[i * 2 + 1];\n            resultValues[i] = Math.hypot(real, imag);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    int(x) {\n        assertNotComplex(x, 'int');\n        const resultValues = new Int32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = values[i];\n        }\n        return this.makeOutput(resultValues, x.shape, 'int32');\n    }\n    sigmoid(x) {\n        assertNotComplex(x, 'sigmoid');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = 1 / (1 + Math.exp(-values[i]));\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    softplus(x) {\n        assertNotComplex(x, 'softplus');\n        // mirrors the implementation of tf.nn.softplus: https://goo.gl/vkcvwX\n        // epsilon is the difference between 1.0 and the next representable float.\n        // For a single precision 32 bit float this should be 2^-23, see:\n        // https://math.byu.edu/~schow/work/IEEEFloatingPoint.htm\n        const epsilon = 1.1920928955078125e-7;\n        const threshold = Math.log(epsilon) + 2.0;\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            // Value above which exp(x) may overflow, but softplus(x) == x\n            // is within machine epsilon.\n            const tooLarge = values[i] > -threshold;\n            // Value below which exp(x) may underflow, but softplus(x) == exp(x)\n            // is within machine epsilon.\n            const tooSmall = values[i] < threshold;\n            const expX = Math.exp(values[i]);\n            let result;\n            if (tooSmall) {\n                result = expX;\n            }\n            else if (tooLarge) {\n                result = values[i];\n            }\n            else {\n                result = Math.log(1.0 + expX);\n            }\n            resultValues[i] = result;\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    sin(x) {\n        assertNotComplex(x, 'sin');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.sin(values[i]);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    tan(x) {\n        assertNotComplex(x, 'tan');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.tan(values[i]);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    asin(x) {\n        assertNotComplex(x, 'asin');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.asin(values[i]);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    acos(x) {\n        assertNotComplex(x, 'acos');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.acos(values[i]);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    atan(x) {\n        assertNotComplex(x, 'atan');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.atan(values[i]);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    atan2(a, b) {\n        assertNotComplex([a, b], 'atan2');\n        return this.broadcastedBinaryOp(a, b, a.dtype, (aValue, bValue) => Math.atan2(aValue, bValue));\n    }\n    sinh(x) {\n        assertNotComplex(x, 'sinh');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.sinh(values[i]);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    cosh(x) {\n        assertNotComplex(x, 'cosh');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.cosh(values[i]);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    tanh(x) {\n        assertNotComplex(x, 'tanh');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = util.tanh(values[i]);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    asinh(x) {\n        assertNotComplex(x, 'asinh');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.asinh(values[i]);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    acosh(x) {\n        assertNotComplex(x, 'acosh');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.acosh(values[i]);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    atanh(x) {\n        assertNotComplex(x, 'atanh');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.atanh(values[i]);\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    erf(x) {\n        assertNotComplex(x, 'erf');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        const p = backend_util.ERF_P;\n        const a1 = backend_util.ERF_A1;\n        const a2 = backend_util.ERF_A2;\n        const a3 = backend_util.ERF_A3;\n        const a4 = backend_util.ERF_A4;\n        const a5 = backend_util.ERF_A5;\n        for (let i = 0; i < values.length; ++i) {\n            const sign = Math.sign(values[i]);\n            const v = Math.abs(values[i]);\n            const t = 1.0 / (1.0 + p * v);\n            resultValues[i] = sign *\n                (1.0 -\n                    (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t *\n                        Math.exp(-v * v));\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    step(x, alpha = 0) {\n        assertNotComplex(x, 'step');\n        const resultValues = new Float32Array(x.size);\n        const values = this.readSync(x.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            const value = values[i];\n            if (isNaN(value)) {\n                resultValues[i] = NaN;\n            }\n            else {\n                resultValues[i] = value > 0 ? 1 : alpha;\n            }\n        }\n        return this.makeOutput(resultValues, x.shape, 'float32');\n    }\n    fusedConv2d({ input, filter, convInfo, bias, activation, preluActivationWeights }) {\n        let result = this.conv2d(input, filter, convInfo);\n        if (bias) {\n            result = this.add(result, bias);\n        }\n        if (activation) {\n            result =\n                mapActivation(this, result, activation, preluActivationWeights);\n        }\n        return result;\n    }\n    conv2d(x, filter, convInfo) {\n        assertNotComplex([x, filter], 'conv2d');\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const padLeft = convInfo.padInfo.left;\n        const padTop = convInfo.padInfo.top;\n        const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n        const y = tf.buffer(convInfo.outShape, x.dtype);\n        const xBatchStride = x.strides[0];\n        const xRowStride = isChannelsLast ? x.strides[1] : x.strides[2];\n        const xColStride = isChannelsLast ? x.strides[2] : 1;\n        const xChannelStride = isChannelsLast ? 1 : x.strides[1];\n        const yBatchStride = y.strides[0];\n        const yRowStride = isChannelsLast ? y.strides[1] : y.strides[2];\n        const yColStride = isChannelsLast ? y.strides[2] : 1;\n        const yChannelStride = isChannelsLast ? 1 : y.strides[1];\n        const xVals = this.readSync(x.dataId);\n        const wVals = this.readSync(filter.dataId);\n        const yVals = y.values;\n        for (let b = 0; b < convInfo.batchSize; ++b) {\n            const xOffset1 = b * xBatchStride;\n            const yOffset1 = b * yBatchStride;\n            for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n                const yOffset2 = yOffset1 + yR * yRowStride;\n                const xRCorner = yR * convInfo.strideHeight - padTop;\n                for (let wR = 0; wR < filterHeight; wR++) {\n                    const xR = xRCorner + wR * dilationHeight;\n                    if (xR < 0 || xR >= convInfo.inHeight) {\n                        continue;\n                    }\n                    const wOffset1 = wR * filter.strides[0];\n                    const xOffset2 = xOffset1 + xR * xRowStride;\n                    for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n                        const yOffset3 = yOffset2 + yC * yColStride;\n                        const xCCorner = yC * convInfo.strideWidth - padLeft;\n                        for (let wC = 0; wC < filterWidth; wC++) {\n                            const xC = xCCorner + wC * dilationWidth;\n                            if (xC < 0 || xC >= convInfo.inWidth) {\n                                continue;\n                            }\n                            const wOffset2 = wOffset1 + wC * filter.strides[1];\n                            const xOffset3 = xOffset2 + xC * xColStride;\n                            let wOffset3 = wOffset2;\n                            for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {\n                                const xVal = xVals[xOffset3 + d1 * xChannelStride];\n                                for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {\n                                    yVals[yOffset3 + d2 * yChannelStride] +=\n                                        xVal * wVals[wOffset3 + d2];\n                                }\n                                wOffset3 += convInfo.outChannels;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return y.toTensor();\n    }\n    conv3d(x, filter, convInfo) {\n        const filterDepth = convInfo.filterDepth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const padFront = convInfo.padInfo.front;\n        const padLeft = convInfo.padInfo.left;\n        const padTop = convInfo.padInfo.top;\n        const y = tf.buffer(convInfo.outShape, x.dtype);\n        const xVals = this.readSync(x.dataId);\n        const wVals = this.readSync(filter.dataId);\n        const yVals = y.values;\n        for (let b = 0; b < convInfo.batchSize; ++b) {\n            const xOffset1 = b * x.strides[0];\n            const yOffset1 = b * y.strides[0];\n            for (let yF = 0; yF < convInfo.outDepth; ++yF) {\n                const yOffset2 = yOffset1 + yF * y.strides[1];\n                const xFCorner = yF * convInfo.strideDepth - padFront;\n                for (let wF = 0; wF < filterDepth; wF++) {\n                    const xF = xFCorner + wF * dilationDepth;\n                    if (xF < 0 || xF >= convInfo.inDepth) {\n                        continue;\n                    }\n                    const wOffset1 = wF * filter.strides[0];\n                    const xOffset2 = xOffset1 + xF * x.strides[1];\n                    for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n                        const yOffset3 = yOffset2 + yR * y.strides[2];\n                        const xRCorner = yR * convInfo.strideHeight - padTop;\n                        for (let wR = 0; wR < filterHeight; wR++) {\n                            const xR = xRCorner + wR * dilationHeight;\n                            if (xR < 0 || xR >= convInfo.inHeight) {\n                                continue;\n                            }\n                            const wOffset2 = wOffset1 + wR * filter.strides[1];\n                            const xOffset3 = xOffset2 + xR * x.strides[2];\n                            for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n                                const yOffset4 = yOffset3 + yC * convInfo.outChannels;\n                                const xCCorner = yC * convInfo.strideWidth - padLeft;\n                                for (let wC = 0; wC < filterWidth; wC++) {\n                                    const xC = xCCorner + wC * dilationWidth;\n                                    if (xC < 0 || xC >= convInfo.inWidth) {\n                                        continue;\n                                    }\n                                    const wOffset3 = wOffset2 + wC * filter.strides[2];\n                                    const xOffset4 = xOffset3 + xC * convInfo.inChannels;\n                                    let wOffset4 = wOffset3;\n                                    for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {\n                                        const xVal = xVals[xOffset4 + d1];\n                                        for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {\n                                            yVals[yOffset4 + d2] += xVal * wVals[wOffset4 + d2];\n                                        }\n                                        wOffset4 += convInfo.outChannels;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return y.toTensor();\n    }\n    conv2dDerInput(dy, filter, convInfo) {\n        assertNotComplex([dy, filter], 'conv2dDerInput');\n        const dx = tf.buffer(convInfo.inShape, 'float32');\n        const dxValues = dx.values;\n        const dyValues = this.readSync(dy.dataId);\n        const fltValues = this.readSync(filter.dataId);\n        const [fltS0, fltS1, fltS2] = filter.strides;\n        const { batchSize, filterHeight, filterWidth, inChannels, inHeight, inWidth, outChannels, outHeight, outWidth, strideHeight, strideWidth, dataFormat } = convInfo;\n        const topPad = filterHeight - 1 - convInfo.padInfo.top;\n        const leftPad = filterWidth - 1 - convInfo.padInfo.left;\n        const isChannelsLast = dataFormat === 'channelsLast';\n        const xBatchStride = dx.strides[0];\n        const xRowStride = isChannelsLast ? dx.strides[1] : dx.strides[2];\n        const xColStride = isChannelsLast ? dx.strides[2] : 1;\n        const xChannelStride = isChannelsLast ? 1 : dx.strides[1];\n        const yBatchStride = dy.strides[0];\n        const yRowStride = isChannelsLast ? dy.strides[1] : dy.strides[2];\n        const yColStride = isChannelsLast ? dy.strides[2] : 1;\n        const yChannelStride = isChannelsLast ? 1 : dy.strides[1];\n        for (let b = 0; b < batchSize; ++b) {\n            for (let d1 = 0; d1 < inChannels; ++d1) {\n                for (let xR = 0; xR < inHeight; ++xR) {\n                    const xRCorner = xR - topPad;\n                    const xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));\n                    const yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);\n                    for (let xC = 0; xC < inWidth; ++xC) {\n                        const xCCorner = xC - leftPad;\n                        const xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));\n                        const yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);\n                        let dotProd = 0;\n                        for (let yR = xRMin; yR < yRMax; ++yR) {\n                            const wR = yR * strideHeight - xRCorner;\n                            for (let yC = xCMin; yC < yCMax; ++yC) {\n                                const wC = yC * strideWidth - xCCorner;\n                                const dyOffset = yBatchStride * b + yRowStride * yR + yColStride * yC;\n                                const fltOffset = fltS0 * (filterHeight - 1 - wR) +\n                                    fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;\n                                for (let d2 = 0; d2 < outChannels; ++d2) {\n                                    const pixel = dyValues[dyOffset + yChannelStride * d2];\n                                    const weight = fltValues[fltOffset + d2];\n                                    dotProd += pixel * weight;\n                                }\n                            }\n                        }\n                        const dxOffset = xBatchStride * b + xRowStride * xR +\n                            xColStride * xC + xChannelStride * d1;\n                        dxValues[dxOffset] = dotProd;\n                    }\n                }\n            }\n        }\n        return dx.toTensor();\n    }\n    conv3dDerInput(dy, filter, convInfo) {\n        const dx = tf.buffer(convInfo.inShape, 'float32');\n        const dxValues = dx.values;\n        const [dxS0, dxS1, dxS2, dxS3] = dx.strides;\n        const dyValues = this.readSync(dy.dataId);\n        const [dyS0, dyS1, dyS2, dyS3] = dy.strides;\n        const fltValues = this.readSync(filter.dataId);\n        const [fltS0, fltS1, fltS2, fltS3] = filter.strides;\n        const { batchSize, filterDepth, filterHeight, filterWidth, inChannels, inDepth, inHeight, inWidth, outChannels, outDepth, outHeight, outWidth, strideDepth, strideHeight, strideWidth } = convInfo;\n        const frontPad = filterDepth - 1 - convInfo.padInfo.front;\n        const topPad = filterHeight - 1 - convInfo.padInfo.top;\n        const leftPad = filterWidth - 1 - convInfo.padInfo.left;\n        for (let b = 0; b < batchSize; ++b) {\n            for (let d1 = 0; d1 < inChannels; ++d1) {\n                // Frames of depth\n                for (let xF = 0; xF < inDepth; ++xF) {\n                    const xFCorner = xF - frontPad;\n                    const xFMin = Math.max(0, Math.ceil(xFCorner / strideDepth));\n                    const yFMax = Math.min(outDepth, (filterDepth + xFCorner) / strideDepth);\n                    // Rows as per standard 2d matrix notation\n                    for (let xR = 0; xR < inHeight; ++xR) {\n                        const xRCorner = xR - topPad;\n                        const xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));\n                        const yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);\n                        // Columns as per standard 2d matrix notation\n                        for (let xC = 0; xC < inWidth; ++xC) {\n                            const xCCorner = xC - leftPad;\n                            const xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));\n                            const yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);\n                            let dotProd = 0;\n                            for (let yF = xFMin; yF < yFMax; ++yF) {\n                                const wF = yF * strideDepth - xFCorner;\n                                for (let yR = xRMin; yR < yRMax; ++yR) {\n                                    const wR = yR * strideHeight - xRCorner;\n                                    for (let yC = xCMin; yC < yCMax; ++yC) {\n                                        const wC = yC * strideWidth - xCCorner;\n                                        const dyOffset = dyS0 * b + dyS1 * yF + dyS2 * yR + dyS3 * yC;\n                                        const fltOffset = fltS0 * (filterDepth - 1 - wF) +\n                                            fltS1 * (filterHeight - 1 - wR) +\n                                            fltS2 * (filterWidth - 1 - wC) + fltS3 * d1;\n                                        for (let d2 = 0; d2 < outChannels; ++d2) {\n                                            const pixel = dyValues[dyOffset + d2];\n                                            const weight = fltValues[fltOffset + d2];\n                                            dotProd += pixel * weight;\n                                        }\n                                    }\n                                }\n                            }\n                            dxValues[dxS0 * b + dxS1 * xF + dxS2 * xR + dxS3 * xC + d1] =\n                                dotProd;\n                        }\n                    }\n                }\n            }\n        }\n        return dx.toTensor();\n    }\n    conv2dDerFilter(x, dy, convInfo) {\n        assertNotComplex([x, dy], 'conv2dDerFilter');\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n        const dW = tf.buffer(convInfo.filterShape, 'float32');\n        const leftPad = convInfo.padInfo.left;\n        const topPad = convInfo.padInfo.top;\n        const xBuf = this.bufferSync(x);\n        const dyBuf = this.bufferSync(dy);\n        for (let wR = 0; wR < filterHeight; ++wR) {\n            const yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));\n            const yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);\n            for (let wC = 0; wC < filterWidth; ++wC) {\n                const yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));\n                const yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);\n                for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {\n                    for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {\n                        // Need to convolve.\n                        let dotProd = 0;\n                        for (let b = 0; b < convInfo.batchSize; ++b) {\n                            for (let yR = yRMin; yR < yRMax; ++yR) {\n                                const xR = wR + yR * strideHeight - topPad;\n                                for (let yC = yCMin; yC < yCMax; ++yC) {\n                                    const xC = wC + yC * strideWidth - leftPad;\n                                    if (isChannelsLast) {\n                                        dotProd +=\n                                            xBuf.get(b, xR, xC, d1) * dyBuf.get(b, yR, yC, d2);\n                                    }\n                                    else {\n                                        dotProd +=\n                                            xBuf.get(b, d1, xR, xC) * dyBuf.get(b, d2, yR, yC);\n                                    }\n                                }\n                            }\n                        }\n                        dW.set(dotProd, wR, wC, d1, d2);\n                    }\n                }\n            }\n        }\n        return dW.toTensor();\n    }\n    conv3dDerFilter(x, dy, convInfo) {\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const filterDepth = convInfo.filterDepth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const dw = tf.buffer(convInfo.filterShape, 'float32');\n        const dwValues = dw.values;\n        const [dwS0, dwS1, dwS2, dwS3] = dw.strides;\n        const dyValues = this.readSync(dy.dataId);\n        const [dyS0, dyS1, dyS2, dyS3] = dy.strides;\n        const xValues = this.readSync(x.dataId);\n        const [xS0, xS1, xS2, xS3] = x.strides;\n        const frontPad = convInfo.padInfo.front;\n        const leftPad = convInfo.padInfo.left;\n        const topPad = convInfo.padInfo.top;\n        for (let wF = 0; wF < filterDepth; ++wF) {\n            const yFMin = Math.max(0, Math.ceil((frontPad - wF) / strideDepth));\n            const yFMax = Math.min(convInfo.outDepth, (convInfo.inDepth + frontPad - wF) / strideDepth);\n            const wOffset1 = wF * dwS0;\n            for (let wR = 0; wR < filterHeight; ++wR) {\n                const yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));\n                const yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);\n                const wOffset2 = wR * dwS1 + wOffset1;\n                for (let wC = 0; wC < filterWidth; ++wC) {\n                    const yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));\n                    const yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);\n                    const wOffset3 = wC * dwS2 + wOffset2;\n                    for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {\n                        const wOffset4 = d1 * dwS3 + wOffset3;\n                        for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {\n                            let dotProd = 0;\n                            for (let b = 0; b < convInfo.batchSize; ++b) {\n                                const xOffset1 = b * xS0;\n                                const yOffset1 = b * dyS0;\n                                for (let yF = yFMin; yF < yFMax; ++yF) {\n                                    const xF = wF + yF * strideDepth - frontPad;\n                                    const xOffset2 = xF * xS1 + xOffset1;\n                                    const yOffset2 = yF * dyS1 + yOffset1;\n                                    for (let yR = yRMin; yR < yRMax; ++yR) {\n                                        const xR = wR + yR * strideHeight - topPad;\n                                        const xOffset3 = xR * xS2 + xOffset2;\n                                        const yOffset3 = yR * dyS2 + yOffset2;\n                                        for (let yC = yCMin; yC < yCMax; ++yC) {\n                                            const xC = wC + yC * strideWidth - leftPad;\n                                            const xOffset4 = xC * xS3 + xOffset3;\n                                            const yOffset4 = yC * dyS3 + yOffset3;\n                                            dotProd +=\n                                                xValues[xOffset4 + d1] * dyValues[yOffset4 + d2];\n                                        }\n                                    }\n                                }\n                            }\n                            dwValues[wOffset4 + d2] = dotProd;\n                        }\n                    }\n                }\n            }\n        }\n        return dw.toTensor();\n    }\n    fusedDepthwiseConv2D({ input, filter, convInfo, bias, activation, preluActivationWeights }) {\n        let result = this.depthwiseConv2D(input, filter, convInfo);\n        if (bias) {\n            result = this.add(result, bias);\n        }\n        if (activation) {\n            result =\n                mapActivation(this, result, activation, preluActivationWeights);\n        }\n        return result;\n    }\n    depthwiseConv2D(x, filter, convInfo) {\n        assertNotComplex([x, filter], 'depthwiseConv2D');\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const padLeft = convInfo.padInfo.left;\n        const padTop = convInfo.padInfo.top;\n        const chMul = convInfo.outChannels / convInfo.inChannels;\n        const y = tf.buffer(convInfo.outShape, x.dtype);\n        const xVals = this.readSync(x.dataId);\n        const wVals = this.readSync(filter.dataId);\n        const yVals = y.values;\n        for (let b = 0; b < convInfo.batchSize; ++b) {\n            const xOffset1 = b * x.strides[0];\n            const yOffset1 = b * y.strides[0];\n            for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n                const yOffset2 = yOffset1 + yR * y.strides[1];\n                const xRCorner = yR * convInfo.strideHeight - padLeft;\n                for (let wR = 0; wR < filterHeight; ++wR) {\n                    const xR = xRCorner + wR * dilationHeight;\n                    if (xR < 0 || xR >= convInfo.inHeight) {\n                        continue;\n                    }\n                    const wOffset1 = wR * filter.strides[0];\n                    const xOffset2 = xOffset1 + xR * x.strides[1];\n                    for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n                        const yOffset3 = yOffset2 + yC * y.strides[2];\n                        const xCCorner = yC * convInfo.strideWidth - padTop;\n                        for (let wC = 0; wC < filterWidth; ++wC) {\n                            const xC = xCCorner + wC * dilationWidth;\n                            if (xC < 0 || xC >= convInfo.inWidth) {\n                                continue;\n                            }\n                            const wOffset2 = wOffset1 + wC * filter.strides[1];\n                            const xOffset3 = xOffset2 + xC * convInfo.inChannels;\n                            let yOffset4 = yOffset3;\n                            let wOffset3 = wOffset2;\n                            for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {\n                                const xVal = xVals[xOffset3 + d1];\n                                for (let q = 0; q < chMul; ++q) {\n                                    yVals[yOffset4 + q] += xVal * wVals[wOffset3 + q];\n                                }\n                                yOffset4 += chMul;\n                                wOffset3 += chMul;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return y.toTensor();\n    }\n    depthwiseConv2DDerInput(dy, filter, convInfo) {\n        assertNotComplex([dy, filter], 'depthwiseConv2DDerInput');\n        const dx = tf.buffer(convInfo.inShape, 'float32');\n        const dxValues = dx.values;\n        const [dxS0, dxS1, dxS2] = dx.strides;\n        const dyValues = this.readSync(dy.dataId);\n        const [dyS0, dyS1, dyS2] = dy.strides;\n        const fltValues = this.readSync(filter.dataId);\n        const [fltS0, fltS1, fltS2] = filter.strides;\n        const { batchSize, filterHeight, filterWidth, inChannels, inHeight, inWidth, outChannels, outHeight, outWidth, strideHeight, strideWidth } = convInfo;\n        const topPad = filterHeight - 1 - convInfo.padInfo.top;\n        const leftPad = filterWidth - 1 - convInfo.padInfo.left;\n        const chMul = outChannels / inChannels;\n        for (let b = 0; b < batchSize; ++b) {\n            for (let d1 = 0; d1 < inChannels; ++d1) {\n                for (let xR = 0; xR < inHeight; ++xR) {\n                    const xRCorner = xR - topPad;\n                    const xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));\n                    const yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);\n                    for (let xC = 0; xC < inWidth; ++xC) {\n                        const xCCorner = xC - leftPad;\n                        const xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));\n                        const yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);\n                        let dotProd = 0;\n                        for (let yR = xRMin; yR < yRMax; ++yR) {\n                            const wR = yR * strideHeight - xRCorner;\n                            for (let yC = xCMin; yC < yCMax; ++yC) {\n                                const wC = yC * strideWidth - xCCorner;\n                                const dyOffset = dyS0 * b + dyS1 * yR + dyS2 * yC;\n                                const fltOffset = fltS0 * (filterHeight - 1 - wR) +\n                                    fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;\n                                for (let dm = 0; dm < chMul; ++dm) {\n                                    const d2 = d1 * chMul + dm;\n                                    const pixel = dyValues[dyOffset + d2];\n                                    const weight = fltValues[fltOffset + dm];\n                                    dotProd += pixel * weight;\n                                }\n                            }\n                        }\n                        dxValues[dxS0 * b + dxS1 * xR + dxS2 * xC + d1] = dotProd;\n                    }\n                }\n            }\n        }\n        return dx.toTensor();\n    }\n    depthwiseConv2DDerFilter(x, dy, convInfo) {\n        assertNotComplex([x, dy], 'depthwiseConv2DDerFilter');\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const dW = tf.buffer(convInfo.filterShape, 'float32');\n        const leftPad = convInfo.padInfo.left;\n        const topPad = convInfo.padInfo.top;\n        const chMul = convInfo.outChannels / convInfo.inChannels;\n        const xBuf = this.bufferSync(x);\n        const dyBuf = this.bufferSync(dy);\n        for (let wR = 0; wR < filterHeight; ++wR) {\n            const yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));\n            const yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);\n            for (let wC = 0; wC < filterWidth; ++wC) {\n                const yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));\n                const yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);\n                for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {\n                    const d1 = Math.trunc(d2 / chMul);\n                    const dm = d2 % chMul;\n                    let dotProd = 0;\n                    for (let b = 0; b < convInfo.batchSize; ++b) {\n                        for (let yR = yRMin; yR < yRMax; ++yR) {\n                            const xR = wR + yR * strideHeight - topPad;\n                            for (let yC = yCMin; yC < yCMax; ++yC) {\n                                const xC = wC + yC * strideWidth - leftPad;\n                                dotProd += xBuf.get(b, xR, xC, d1) * dyBuf.get(b, yR, yC, d2);\n                            }\n                        }\n                    }\n                    dW.set(dotProd, wR, wC, d1, dm);\n                }\n            }\n        }\n        return dW.toTensor();\n    }\n    tile(x, reps) {\n        assertNotComplex(x, 'tile');\n        return tile(this.bufferSync(x), reps);\n    }\n    gather(x, indices, axis) {\n        assertNotComplex([x, indices], 'gather');\n        const newShape = x.shape.slice();\n        const indicesValues = this.readSync(indices.dataId);\n        newShape[axis] = indicesValues.length;\n        const result = tf.buffer(newShape, x.dtype);\n        const xBuf = this.bufferSync(x);\n        for (let i = 0; i < result.size; ++i) {\n            const newLoc = result.indexToLoc(i);\n            const originalLoc = newLoc.slice();\n            originalLoc[axis] = indicesValues[newLoc[axis]];\n            const originalIndex = xBuf.locToIndex(originalLoc);\n            result.values[i] = xBuf.values[originalIndex];\n        }\n        return result.toTensor();\n    }\n    batchToSpaceND(x, blockShape, crops) {\n        assertNotComplex([x], 'batchToSpaceND');\n        const prod = blockShape.reduce((a, b) => a * b);\n        const reshaped = backend_util.getReshaped(x.shape, blockShape, prod);\n        const permuted = backend_util.getPermuted(reshaped.length, blockShape.length);\n        const reshapedPermuted = backend_util.getReshapedPermuted(x.shape, blockShape, prod);\n        const sliceBeginCoords = backend_util.getSliceBeginCoords(crops, blockShape.length);\n        const sliceSize = backend_util.getSliceSize(reshapedPermuted, crops, blockShape.length);\n        return tf.transpose(x.reshape(reshaped), permuted)\n            .reshape(reshapedPermuted)\n            .slice(sliceBeginCoords, sliceSize);\n    }\n    maxPool(x, convInfo) {\n        assertNotComplex(x, 'maxPool');\n        const xValues = this.readSync(x.dataId);\n        return pool(xValues, x.shape, x.dtype, x.strides, convInfo, 'max')\n            .toTensor();\n    }\n    maxPoolBackprop(dy, x, y, convInfo) {\n        assertNotComplex([x, y], 'maxPoolBackprop');\n        const xValues = this.readSync(x.dataId);\n        const maxPosBuf = buffer(convInfo.outShape, x.dtype, maxPoolPositions(xValues, x.shape, x.dtype, convInfo).values);\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n        const dx = tf.buffer(x.shape, 'float32');\n        const dyBuf = this.bufferSync(dy);\n        for (let b = 0; b < convInfo.batchSize; ++b) {\n            for (let d = 0; d < convInfo.inChannels; ++d) {\n                for (let dxR = 0; dxR < convInfo.inHeight; ++dxR) {\n                    for (let dxC = 0; dxC < convInfo.inWidth; ++dxC) {\n                        // Shader code begins.\n                        const dyRCorner = dxR - padTop;\n                        const dyCCorner = dxC - padLeft;\n                        let dotProd = 0;\n                        for (let wR = 0; wR < effectiveFilterHeight; wR += dilationHeight) {\n                            const dyR = (dyRCorner + wR) / strideHeight;\n                            if (dyR < 0 || dyR >= convInfo.outHeight ||\n                                Math.floor(dyR) !== dyR) {\n                                continue;\n                            }\n                            for (let wC = 0; wC < effectiveFilterWidth; wC += dilationWidth) {\n                                const dyC = (dyCCorner + wC) / strideWidth;\n                                if (dyC < 0 || dyC >= convInfo.outWidth ||\n                                    Math.floor(dyC) !== dyC) {\n                                    continue;\n                                }\n                                const maxPos = effectiveFilterHeight * effectiveFilterWidth -\n                                    1 - maxPosBuf.get(b, dyR, dyC, d);\n                                const curPos = wR * effectiveFilterWidth + wC;\n                                const mask = maxPos === curPos ? 1 : 0;\n                                if (mask === 0) {\n                                    continue;\n                                }\n                                const pixel = dyBuf.get(b, dyR, dyC, d);\n                                dotProd += pixel * mask;\n                            }\n                        }\n                        dx.set(dotProd, b, dxR, dxC, d);\n                    }\n                }\n            }\n        }\n        return dx.toTensor();\n    }\n    avgPoolBackprop(dy, x, convInfo) {\n        assertNotComplex([dy, x], 'avgPoolBackprop');\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n        const dx = tf.buffer(x.shape, 'float32');\n        const avgMultiplier = 1 / (filterHeight * filterWidth);\n        const dyBuf = this.bufferSync(dy);\n        for (let b = 0; b < convInfo.batchSize; ++b) {\n            for (let d = 0; d < convInfo.inChannels; ++d) {\n                for (let dxR = 0; dxR < convInfo.inHeight; ++dxR) {\n                    for (let dxC = 0; dxC < convInfo.inWidth; ++dxC) {\n                        // Shader code begins.\n                        const dyRCorner = dxR - padTop;\n                        const dyCCorner = dxC - padLeft;\n                        let dotProd = 0;\n                        for (let wR = 0; wR < effectiveFilterHeight; wR += dilationHeight) {\n                            const dyR = (dyRCorner + wR) / strideHeight;\n                            if (dyR < 0 || dyR >= convInfo.outHeight ||\n                                Math.floor(dyR) !== dyR) {\n                                continue;\n                            }\n                            for (let wC = 0; wC < effectiveFilterWidth; wC += dilationWidth) {\n                                const dyC = (dyCCorner + wC) / strideWidth;\n                                if (dyC < 0 || dyC >= convInfo.outWidth ||\n                                    Math.floor(dyC) !== dyC) {\n                                    continue;\n                                }\n                                const pixel = dyBuf.get(b, dyR, dyC, d);\n                                dotProd += pixel;\n                            }\n                        }\n                        dx.set(dotProd * avgMultiplier, b, dxR, dxC, d);\n                    }\n                }\n            }\n        }\n        return dx.toTensor();\n    }\n    pool3d(x, convInfo, poolType) {\n        assertNotComplex(x, 'pool3d');\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padFront = convInfo.padInfo.front;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const initialValue = (poolType === 'max' ? Number.NEGATIVE_INFINITY :\n            Number.POSITIVE_INFINITY);\n        const xValues = this.readSync(x.dataId);\n        const output = tf.buffer(convInfo.outShape, x.dtype);\n        const outputVals = output.values;\n        const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] *\n            convInfo.outShape[3] * convInfo.outShape[4];\n        const outputDepthStrides = convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];\n        const outputRowStrides = convInfo.outShape[3] * convInfo.outShape[4];\n        const outputColStrides = convInfo.outShape[4];\n        for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n            const outputBatchOffset = batch * outputBatchStrides;\n            const inputBatchOffset = batch * x.strides[0];\n            for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n                for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n                    const xDepthCorner = yDepth * strideDepth - padFront;\n                    let xDepthMin = xDepthCorner;\n                    while (xDepthMin < 0) {\n                        xDepthMin += dilationDepth;\n                    }\n                    const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n                    const outputDepthOffset = outputBatchOffset + yDepth * outputDepthStrides;\n                    for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n                        const xRowCorner = yRow * strideHeight - padTop;\n                        let xRowMin = xRowCorner;\n                        while (xRowMin < 0) {\n                            xRowMin += dilationHeight;\n                        }\n                        const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n                        const outputRowOffset = outputDepthOffset + yRow * outputRowStrides;\n                        for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n                            const xColCorner = yCol * strideWidth - padLeft;\n                            let xColMin = xColCorner;\n                            while (xColMin < 0) {\n                                xColMin += dilationWidth;\n                            }\n                            const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);\n                            // Shader code begins\n                            const outputColOffset = outputRowOffset + yCol * outputColStrides;\n                            let minMaxValue = initialValue;\n                            let avgValue = 0;\n                            let count = 0;\n                            for (let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {\n                                const xDepthOffset = inputBatchOffset + xDepth * x.strides[1];\n                                for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                                    const xRowOffset = xDepthOffset + xRow * x.strides[2];\n                                    for (let xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {\n                                        const xColOffset = xRowOffset + xCol * x.strides[3];\n                                        const pixel = xValues[xColOffset + channel];\n                                        if ((poolType === 'max' && pixel > minMaxValue)) {\n                                            minMaxValue = pixel;\n                                        }\n                                        else if (poolType === 'avg') {\n                                            avgValue += pixel;\n                                            count++;\n                                        }\n                                        if (isNaN(minMaxValue)) {\n                                            break;\n                                        }\n                                    }\n                                    if (isNaN(minMaxValue)) {\n                                        break;\n                                    }\n                                }\n                                if (isNaN(minMaxValue)) {\n                                    break;\n                                }\n                            }\n                            const outputOffset = outputColOffset + channel;\n                            outputVals[outputOffset] =\n                                poolType === 'avg' ? avgValue / count : minMaxValue;\n                        }\n                    }\n                }\n            }\n        }\n        return output.toTensor();\n    }\n    avgPool3d(x, convInfo) {\n        assertNotComplex(x, 'avgPool3d');\n        return this.pool3d(x, convInfo, 'avg').toFloat();\n    }\n    avgPool3dBackprop(dy, x, convInfo) {\n        assertNotComplex([dy, x], 'avgPool3dBackprop');\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const filterDepth = convInfo.filterDepth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n        const dx = tf.buffer(x.shape, 'float32');\n        const avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);\n        const dyBuf = this.bufferSync(dy);\n        for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n            for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n                for (let dxDepth = 0; dxDepth < convInfo.inDepth; ++dxDepth) {\n                    for (let dxRow = 0; dxRow < convInfo.inHeight; ++dxRow) {\n                        for (let dxCol = 0; dxCol < convInfo.inWidth; ++dxCol) {\n                            // Shader code begins.\n                            const dyDepthCorner = dxDepth - padFront;\n                            const dyRowCorner = dxRow - padTop;\n                            const dyColCorner = dxCol - padLeft;\n                            let dotProd = 0;\n                            for (let wDepth = 0; wDepth < effectiveFilterDepth; wDepth += dilationDepth) {\n                                const dyDepth = (dyDepthCorner + wDepth) / strideDepth;\n                                if (dyDepth < 0 || dyDepth >= convInfo.outDepth ||\n                                    Math.floor(dyDepth) !== dyDepth) {\n                                    continue;\n                                }\n                                for (let wRow = 0; wRow < effectiveFilterHeight; wRow += dilationHeight) {\n                                    const dyRow = (dyRowCorner + wRow) / strideHeight;\n                                    if (dyRow < 0 || dyRow >= convInfo.outHeight ||\n                                        Math.floor(dyRow) !== dyRow) {\n                                        continue;\n                                    }\n                                    for (let wCol = 0; wCol < effectiveFilterWidth; wCol += dilationWidth) {\n                                        const dyCol = (dyColCorner + wCol) / strideWidth;\n                                        if (dyCol < 0 || dyCol >= convInfo.outWidth ||\n                                            Math.floor(dyCol) !== dyCol) {\n                                            continue;\n                                        }\n                                        const pixel = dyBuf.get(batch, dyDepth, dyRow, dyCol, channel);\n                                        dotProd += pixel;\n                                    }\n                                }\n                            }\n                            dx.set(dotProd * avgMultiplier, batch, dxDepth, dxRow, dxCol, channel);\n                        }\n                    }\n                }\n            }\n        }\n        return dx.toTensor();\n    }\n    maxPool3d(x, convInfo) {\n        assertNotComplex(x, 'maxPool3d');\n        return this.pool3d(x, convInfo, 'max').toFloat();\n    }\n    maxPool3dPositions(x, convInfo) {\n        const maxPositions = tf.buffer(convInfo.outShape, 'int32');\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padFront = convInfo.padInfo.front;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const xBuf = this.bufferSync(x);\n        for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n            for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n                for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n                    const xDepthCorner = yDepth * strideDepth - padFront;\n                    let xDepthMin = xDepthCorner;\n                    while (xDepthMin < 0) {\n                        xDepthMin += dilationDepth;\n                    }\n                    const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n                    for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n                        const xRowCorner = yRow * strideHeight - padTop;\n                        let xRowMin = xRowCorner;\n                        while (xRowMin < 0) {\n                            xRowMin += dilationHeight;\n                        }\n                        const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n                        for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n                            const xColCorner = yCol * strideWidth - padLeft;\n                            let xColMin = xColCorner;\n                            while (xColMin < 0) {\n                                xColMin += dilationWidth;\n                            }\n                            const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);\n                            // Shader code begins\n                            let maxValue = Number.NEGATIVE_INFINITY;\n                            let maxPosition = -1;\n                            for (let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {\n                                const wDepth = xDepth - xDepthCorner;\n                                for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                                    const wRow = xRow - xRowCorner;\n                                    for (let xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {\n                                        const wCol = xCol - xColCorner;\n                                        const pixel = xBuf.get(batch, xDepth, xRow, xCol, channel);\n                                        if (pixel >= maxValue) {\n                                            maxValue = pixel;\n                                            maxPosition = wDepth * effectiveFilterHeight *\n                                                effectiveFilterWidth +\n                                                wRow * effectiveFilterHeight + wCol;\n                                        }\n                                    }\n                                }\n                            }\n                            maxPositions.set(maxPosition, batch, yDepth, yRow, yCol, channel);\n                        }\n                    }\n                }\n            }\n        }\n        return maxPositions.toTensor();\n    }\n    maxPool3dBackprop(dy, x, y, convInfo) {\n        assertNotComplex([x, y], 'maxPool3dBackprop');\n        const maxPositions = this.maxPool3dPositions(x, convInfo);\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n        const dx = tf.buffer(x.shape, 'float32');\n        const maxPosBuf = this.bufferSync(maxPositions);\n        const dyBuf = this.bufferSync(dy);\n        for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n            for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n                for (let dxDepth = 0; dxDepth < convInfo.inDepth; ++dxDepth) {\n                    for (let dxRow = 0; dxRow < convInfo.inHeight; ++dxRow) {\n                        for (let dxCol = 0; dxCol < convInfo.inWidth; ++dxCol) {\n                            // Shader code begins\n                            const dyDepthCorner = dxDepth - padFront;\n                            const dyRowCorner = dxRow - padTop;\n                            const dyColCorner = dxCol - padLeft;\n                            let dotProd = 0;\n                            for (let wDepth = 0; wDepth < effectiveFilterDepth; wDepth += dilationDepth) {\n                                const dyDepth = (dyDepthCorner + wDepth) / strideDepth;\n                                if (dyDepth < 0 || dyDepth >= convInfo.outDepth ||\n                                    Math.floor(dyDepth) !== dyDepth) {\n                                    continue;\n                                }\n                                for (let wRow = 0; wRow < effectiveFilterHeight; wRow += dilationHeight) {\n                                    const dyRow = (dyRowCorner + wRow) / strideHeight;\n                                    if (dyRow < 0 || dyRow >= convInfo.outHeight ||\n                                        Math.floor(dyRow) !== dyRow) {\n                                        continue;\n                                    }\n                                    for (let wCol = 0; wCol < effectiveFilterWidth; wCol += dilationWidth) {\n                                        const dyCol = (dyColCorner + wCol) / strideWidth;\n                                        if (dyCol < 0 || dyCol >= convInfo.outWidth ||\n                                            Math.floor(dyCol) !== dyCol) {\n                                            continue;\n                                        }\n                                        const maxPos = effectiveFilterDepth *\n                                            effectiveFilterHeight * effectiveFilterWidth -\n                                            1 -\n                                            maxPosBuf.get(batch, dyDepth, dyRow, dyCol, channel);\n                                        const curPos = wDepth * effectiveFilterHeight * effectiveFilterWidth +\n                                            wRow * effectiveFilterWidth + wCol;\n                                        const mask = maxPos === curPos ? 1 : 0;\n                                        if (mask === 0) {\n                                            continue;\n                                        }\n                                        const pixel = dyBuf.get(batch, dyDepth, dyRow, dyCol, channel);\n                                        dotProd += pixel * mask;\n                                    }\n                                }\n                            }\n                            dx.set(dotProd, batch, dxDepth, dxRow, dxCol, channel);\n                        }\n                    }\n                }\n            }\n        }\n        return dx.toTensor();\n    }\n    cast(x, dtype) {\n        return backend_util.castTensor(x, dtype, this);\n    }\n    avgPool(x, convInfo) {\n        assertNotComplex(x, 'avgPool');\n        assertNotComplex(x, 'maxPool');\n        const xValues = this.readSync(x.dataId);\n        return pool(xValues, x.shape, x.dtype, x.strides, convInfo, 'avg')\n            .toTensor()\n            .toFloat();\n    }\n    resizeBilinear(x, newHeight, newWidth, alignCorners) {\n        assertNotComplex(x, 'resizeBilinear');\n        const [batch, oldHeight, oldWidth, numChannels] = x.shape;\n        const xValues = this.readSync(x.dataId);\n        const result = new Float32Array(util.sizeFromShape([batch, newHeight, newWidth, numChannels]));\n        const effectiveInputSize = [\n            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n        ];\n        const effectiveOutputSize = [\n            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n        ];\n        let outputIdx = 0;\n        const effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];\n        const effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];\n        for (let b = 0; b < batch; b++) {\n            for (let r = 0; r < newHeight; r++) {\n                const sourceFracRow = effectiveRowSizeRatio * r;\n                const sourceRowFloor = Math.floor(sourceFracRow);\n                const rowFrac = sourceFracRow - sourceRowFloor;\n                const sourceRowCeil = Math.min(oldHeight - 1, Math.ceil(sourceFracRow));\n                const topRowOffset = b * x.strides[0] + sourceRowFloor * x.strides[1];\n                const botRowOffset = b * x.strides[0] + sourceRowCeil * x.strides[1];\n                for (let c = 0; c < newWidth; c++) {\n                    const sourceFracCol = effectiveColSizeRatio * c;\n                    const sourceColFloor = Math.floor(sourceFracCol);\n                    const colFrac = sourceFracCol - sourceColFloor;\n                    const sourceColCeil = Math.min(oldWidth - 1, Math.ceil(sourceFracCol));\n                    const topLeftOffest = topRowOffset + sourceColFloor * x.strides[2];\n                    const botLeftOffset = botRowOffset + sourceColFloor * x.strides[2];\n                    const topRightOffset = topRowOffset + sourceColCeil * x.strides[2];\n                    const botRightOffest = botRowOffset + sourceColCeil * x.strides[2];\n                    for (let d = 0; d < numChannels; d++) {\n                        // Begin shader.\n                        // Compute the fractional index of the source.\n                        const topLeft = xValues[topLeftOffest + d];\n                        const bottomLeft = xValues[botLeftOffset + d];\n                        const topRight = xValues[topRightOffset + d];\n                        const bottomRight = xValues[botRightOffest + d];\n                        const top = topLeft + (topRight - topLeft) * colFrac;\n                        const bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;\n                        const newValue = top + (bottom - top) * rowFrac;\n                        result[outputIdx++] = newValue;\n                    }\n                }\n            }\n        }\n        return tf.tensor(result, [batch, newHeight, newWidth, numChannels]);\n    }\n    resizeBilinearBackprop(dy, x, alignCorners) {\n        assertNotComplex([dy, x], 'resizeBilinearBackprop');\n        const [batch, xHeight, xWidth, depth] = x.shape;\n        const [, yHeight, yWidth] = dy.shape;\n        const output = new Float32Array(batch * xHeight * xWidth * depth);\n        // In the backwards pass, we want to find the pixels that were generated\n        // for each pixel in the input image the forward pass and add the\n        // corresponding coefficient from dy to the gradient (with some\n        // interpolation).\n        const effectiveXSize = [\n            (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n            (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n        ];\n        const effectiveYSize = [\n            (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n            (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n        ];\n        const heightScale = effectiveXSize[0] / effectiveYSize[0];\n        const widthScale = effectiveXSize[1] / effectiveYSize[1];\n        // Reference implementation\n        // tslint:disable-next-line:max-line-length\n        // https://github.com/tensorflow/tensorflow/blob/3039375c86a5bbc9610c7725dcaa95d635f87ba2/tensorflow/core/kernels/resize_bilinear_op.cc#L275\n        const dyValues = this.readSync(dy.dataId);\n        let offset = 0;\n        for (let b = 0; b < batch; b++) {\n            const bOffset = b * x.strides[0];\n            for (let r = 0; r < yHeight; r++) {\n                const dxR = r * heightScale;\n                const topDxRIndex = Math.floor(dxR);\n                const bottomDxRIndex = Math.min(Math.ceil(dxR), xHeight - 1);\n                const topDxROffset = bOffset + topDxRIndex * x.strides[1];\n                const bottomDxROffset = bOffset + bottomDxRIndex * x.strides[1];\n                const dxRLerp = dxR - topDxRIndex;\n                const inverseDxRLerp = 1.0 - dxRLerp;\n                for (let c = 0; c < yWidth; c++) {\n                    const dxC = c * widthScale;\n                    const leftDxCIndex = Math.floor(dxC);\n                    const rightDxCIndex = Math.min(Math.ceil(dxC), xWidth - 1);\n                    const dxCLerp = dxC - leftDxCIndex;\n                    const inverseDxCLerp = 1.0 - dxCLerp;\n                    const topLeftRCOffset = topDxROffset + leftDxCIndex * x.strides[2];\n                    const topRightRCOffset = topDxROffset + rightDxCIndex * x.strides[2];\n                    const bottomLeftRCOffset = bottomDxROffset + leftDxCIndex * x.strides[2];\n                    const bottomRightRCOffset = bottomDxROffset + rightDxCIndex * x.strides[2];\n                    const inverseDxRLerpTimesInverseDxCLerp = inverseDxRLerp * inverseDxCLerp;\n                    const inverseDxRLerpTimesDxCLerp = inverseDxRLerp * dxCLerp;\n                    const dxRLerpTimesInverseDxCLerp = dxRLerp * inverseDxCLerp;\n                    const dxRLerpTimesDxCLerp = dxRLerp * dxCLerp;\n                    for (let d = 0; d < depth; d++) {\n                        const dyVal = dyValues[offset++];\n                        output[topLeftRCOffset + d] +=\n                            dyVal * inverseDxRLerpTimesInverseDxCLerp;\n                        output[topRightRCOffset + d] += dyVal * inverseDxRLerpTimesDxCLerp;\n                        output[bottomLeftRCOffset + d] +=\n                            dyVal * dxRLerpTimesInverseDxCLerp;\n                        output[bottomRightRCOffset + d] += dyVal * dxRLerpTimesDxCLerp;\n                    }\n                }\n            }\n        }\n        return tf.tensor4d(output, [batch, xWidth, xHeight, depth], x.dtype);\n    }\n    resizeNearestNeighbor(x, newHeight, newWidth, alignCorners) {\n        assertNotComplex(x, 'resizeNearestNeighbor');\n        const [batch, oldHeight, oldWidth, numChannels] = x.shape;\n        const xValues = this.readSync(x.dataId);\n        const output = new Float32Array(batch * newHeight * newWidth * numChannels);\n        const effectiveInputSize = [\n            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n        ];\n        const effectiveOutputSize = [\n            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n        ];\n        const effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];\n        const effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];\n        let outputOffset = 0;\n        for (let b = 0; b < batch; b++) {\n            const batchOffset = b * x.strides[0];\n            for (let r = 0; r < newHeight; r++) {\n                const sourceFracRow = effectiveRowSizeRatio * r;\n                const sourceNearestRow = Math.min(oldHeight - 1, alignCorners ? Math.round(sourceFracRow) :\n                    Math.floor(sourceFracRow));\n                const rowOffset = batchOffset + sourceNearestRow * x.strides[1];\n                for (let c = 0; c < newWidth; c++) {\n                    const sourceFracCol = effectiveColSizeRatio * c;\n                    const sourceNearestCol = Math.min(oldWidth - 1, alignCorners ? Math.round(sourceFracCol) :\n                        Math.floor(sourceFracCol));\n                    const colOffset = rowOffset + sourceNearestCol * x.strides[2];\n                    for (let d = 0; d < numChannels; d++) {\n                        // Begin shader.\n                        // Compute the fractional index of the source.\n                        const newVal = xValues[colOffset + d];\n                        output[outputOffset++] = newVal;\n                    }\n                }\n            }\n        }\n        return tf.tensor(output, [batch, newHeight, newWidth, numChannels], x.dtype);\n    }\n    resizeNearestNeighborBackprop(dy, x, alignCorners) {\n        assertNotComplex([dy, x], 'resizeNearestNeighborBackprop');\n        const [batch, xHeight, xWidth, depth] = x.shape;\n        const [, yHeight, yWidth] = dy.shape;\n        const output = new Float32Array(batch * xHeight * xWidth * depth);\n        const dyValues = this.readSync(dy.dataId);\n        // In the backwards pass, we want to find the pixels that were generated\n        // for each pixel in the input image the forward pass\n        const effectiveXSize = [\n            (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n            (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n        ];\n        const effectiveYSize = [\n            (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n            (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n        ];\n        const heightScale = effectiveXSize[0] / effectiveYSize[0];\n        const widthScale = effectiveXSize[1] / effectiveYSize[1];\n        const invHeightScale = 1 / heightScale;\n        const invWidthScale = 1 / widthScale;\n        // This defines the size of the window of values around a particular\n        // index in dy that we want to search for contributions to dx.\n        const winHeight = (Math.ceil(invHeightScale) * 2) + 2;\n        const winWidth = (Math.ceil(invWidthScale) * 2) + 2;\n        // Loop over the output space.\n        for (let b = 0; b < batch; b++) {\n            const batchOffset = b * x.strides[0];\n            for (let r = 0; r < xHeight; r++) {\n                const rowOffset = batchOffset + r * x.strides[1];\n                // Compute bounds for where in dy we will look\n                const startRLerp = Math.floor(r * invHeightScale);\n                const startDyR = Math.floor(startRLerp - (winHeight / 2));\n                for (let c = 0; c < xWidth; c++) {\n                    const colOffset = rowOffset + c * x.strides[2];\n                    // Compute bounds for where in dy we will look\n                    const startCLerp = Math.floor(c * invWidthScale);\n                    const startDyC = Math.floor(startCLerp - (winWidth / 2));\n                    for (let d = 0; d < depth; d++) {\n                        let accum = 0;\n                        // loop over dy\n                        for (let dyRIndex = 0; dyRIndex < winHeight; dyRIndex++) {\n                            const dyR = dyRIndex + startDyR;\n                            // Guard against the window exceeding the bounds of dy\n                            if (dyR < 0 || dyR >= yHeight) {\n                                continue;\n                            }\n                            const dyROffset = batchOffset + dyR * dy.strides[1];\n                            const sourceFracRow = dyR * heightScale;\n                            const sourceNearestRow = Math.min(xHeight - 1, alignCorners ? Math.round(sourceFracRow) :\n                                Math.floor(sourceFracRow));\n                            if (r !== sourceNearestRow) {\n                                continue;\n                            }\n                            for (let dyCIndex = 0; dyCIndex < winWidth; dyCIndex++) {\n                                const dyC = dyCIndex + startDyC;\n                                // Guard against the window exceeding the bounds of dy\n                                if (dyC < 0 || dyC >= yWidth) {\n                                    continue;\n                                }\n                                const dyCOffset = dyROffset + dyC * dy.strides[2];\n                                const sourceFracCol = dyC * widthScale;\n                                const sourceNearestCol = Math.min(xWidth - 1, alignCorners ? Math.round(sourceFracCol) :\n                                    Math.floor(sourceFracCol));\n                                if (c === sourceNearestCol) {\n                                    accum += dyValues[dyCOffset + d];\n                                }\n                            }\n                        }\n                        output[colOffset + d] = accum;\n                    }\n                }\n            }\n        }\n        return tf.tensor4d(output, x.shape, x.dtype);\n    }\n    batchNorm(x, mean, variance, offset, scale, varianceEpsilon) {\n        assertNotComplex([x, mean, variance, scale, offset], 'batchNorm');\n        const xVals = this.readSync(x.dataId);\n        const mVals = this.readSync(mean.dataId);\n        const varVals = this.readSync(variance.dataId);\n        const sVals = scale ? this.readSync(scale.dataId) :\n            new Float32Array([1]);\n        const offVals = offset ? this.readSync(offset.dataId) :\n            new Float32Array([0]);\n        const outVals = new Float32Array(xVals.length);\n        const offValsLength = offVals.length;\n        const sValsLength = sVals.length;\n        const varValsLength = varVals.length;\n        const mValsLength = mVals.length;\n        let offi = 0;\n        let mi = 0;\n        let si = 0;\n        let vi = 0;\n        for (let i = 0; i < xVals.length; ++i) {\n            outVals[i] = offVals[offi++] +\n                (xVals[i] - mVals[mi++]) * sVals[si++] /\n                    Math.sqrt(varVals[vi++] + varianceEpsilon);\n            if (offi >= offValsLength) {\n                offi = 0;\n            }\n            if (mi >= mValsLength) {\n                mi = 0;\n            }\n            if (si >= sValsLength) {\n                si = 0;\n            }\n            if (vi >= varValsLength) {\n                vi = 0;\n            }\n        }\n        return tf.tensor4d(outVals, x.shape);\n    }\n    localResponseNormalization4D(x, depthRadius, bias, alpha, beta) {\n        assertNotComplex(x, 'localResponseNormalization4D');\n        const channels = x.shape[3];\n        const maxD = channels - 1;\n        const xValues = this.readSync(x.dataId);\n        const size = x.size;\n        const result = new Float32Array(size);\n        function sumAcrossChannels(offset) {\n            const currentChannel = offset % channels;\n            let beginSumOffset = offset - currentChannel + Math.max(0, currentChannel - depthRadius);\n            const endSumOffset = offset - currentChannel +\n                Math.min(currentChannel + depthRadius, maxD);\n            let sum = 0.0;\n            for (; beginSumOffset <= endSumOffset; beginSumOffset++) {\n                const z = xValues[beginSumOffset];\n                sum += z * z;\n            }\n            return sum;\n        }\n        for (let offset = 0; offset < size; offset++) {\n            const sum = sumAcrossChannels(offset);\n            const val = xValues[offset] * Math.pow(bias + alpha * sum, -beta);\n            result[offset] = val;\n        }\n        return tf.tensor4d(result, x.shape);\n    }\n    LRNGrad(dy, inputImage, outputImage, depthRadius, bias, alpha, beta) {\n        assertNotComplex(dy, 'LRNGrad');\n        const channels = dy.shape[3];\n        const dyValues = this.readSync(dy.dataId);\n        const inputImageValues = this.readSync(inputImage.dataId);\n        const outputImageValues = this.readSync(outputImage.dataId);\n        const result = new Float32Array(dy.size);\n        const size = dy.size;\n        for (let offset = 0; offset < size; offset++) {\n            const currentChannel = offset % channels;\n            const depthBegin = (offset - currentChannel) + Math.max(0, currentChannel - depthRadius);\n            const depthEnd = (offset - currentChannel) +\n                Math.min(channels, currentChannel + depthRadius + 1);\n            let norm = 0;\n            for (let k = depthBegin; k < depthEnd; k++) {\n                norm += Math.pow(inputImageValues[k], 2);\n            }\n            norm = alpha * norm + bias;\n            for (let k = depthBegin; k < depthEnd; k++) {\n                let dyi = -2 * alpha * beta * inputImageValues[k] *\n                    outputImageValues[offset] / norm;\n                if (offset === k) {\n                    dyi += Math.pow(norm, -beta);\n                }\n                dyi *= dyValues[offset];\n                result[k] += dyi;\n            }\n        }\n        return tf.tensor4d(result, dy.shape);\n    }\n    multinomial(logits, normalized, numSamples, seed) {\n        assertNotComplex(logits, 'multinomial');\n        const probabilities = normalized ? logits : tf.softmax(logits);\n        const batchSize = probabilities.shape[0];\n        const numEvents = probabilities.shape[1];\n        const res = tf.zeros([batchSize, numSamples], 'int32');\n        const resVals = this.readSync(res.dataId);\n        const probVals = this.readSync(probabilities.dataId);\n        for (let b = 0; b < batchSize; ++b) {\n            const offset = b * numEvents;\n            // The cdf won't include the last event. It will be implicit if no other\n            // event happened.\n            const cdf = new Float32Array(numEvents - 1);\n            cdf[0] = probVals[offset];\n            for (let event = 1; event < cdf.length; ++event) {\n                cdf[event] = cdf[event - 1] + probVals[offset + event];\n            }\n            const random = seedrandom.alea(seed.toString());\n            const outOffset = b * numSamples;\n            for (let sampleId = 0; sampleId < numSamples; ++sampleId) {\n                const r = random();\n                // Assume last event happened by default.\n                resVals[outOffset + sampleId] = cdf.length;\n                for (let event = 0; event < cdf.length; event++) {\n                    if (r < cdf[event]) {\n                        resVals[outOffset + sampleId] = event;\n                        break;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    oneHot(indices, depth, onValue, offValue) {\n        assertNotComplex(indices, 'oneHot');\n        const res = new Float32Array(indices.size * depth);\n        res.fill(offValue);\n        const indicesVal = this.readSync(indices.dataId);\n        for (let event = 0; event < indices.size; ++event) {\n            if (indicesVal[event] >= 0 && indicesVal[event] < depth) {\n                res[event * depth + indicesVal[event]] = onValue;\n            }\n        }\n        return tf.tensor2d(res, [indices.size, depth], 'int32');\n    }\n    nonMaxSuppression(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {\n        assertNotComplex(boxes, 'nonMaxSuppression');\n        const boxesVals = this.readSync(boxes.dataId);\n        const scoresVals = this.readSync(scores.dataId);\n        return nonMaxSuppressionV3Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);\n    }\n    fft(x) {\n        return this.fftBatch(x, false);\n    }\n    ifft(x) {\n        return this.fftBatch(x, true);\n    }\n    /**\n     * Calculate FFT of inner most elements of batch tensor.\n     */\n    fftBatch(x, inverse) {\n        const batch = x.shape[0];\n        const innerDim = x.shape[1];\n        // Collects real and imaginary values separately.\n        const realResult = tf.buffer(x.shape, 'float32');\n        const imagResult = tf.buffer(x.shape, 'float32');\n        const real = tf.real(x).as2D(batch, innerDim);\n        const imag = tf.imag(x).as2D(batch, innerDim);\n        for (let b = 0; b < batch; b++) {\n            // TODO: Support slice ops for complex type.\n            const r = real.slice([b, 0], [1, innerDim]);\n            const i = imag.slice([b, 0], [1, innerDim]);\n            const input = tf.complex(r, i);\n            // Run FFT by batch element.\n            const res = this.readSync(this.fftImpl(input, inverse).dataId);\n            for (let d = 0; d < innerDim; d++) {\n                const c = backend_util.getComplexWithIndex(res, d);\n                realResult.values[b * innerDim + d] = c.real;\n                imagResult.values[b * innerDim + d] = c.imag;\n            }\n        }\n        const t = tf.complex(realResult.toTensor(), imagResult.toTensor());\n        return t.as2D(batch, innerDim);\n    }\n    fftImpl(x, inverse) {\n        const x1D = x.as1D();\n        const n = x1D.size;\n        if (this.isExponentOf2(n)) {\n            let result = this.fftRadix2(x1D, n, inverse).as2D(x.shape[0], x.shape[1]);\n            if (inverse) {\n                result = tf.complex(tf.real(result).div(tf.scalar(n)), tf.imag(result).div(tf.scalar(n)));\n            }\n            return result;\n        }\n        else {\n            const data = this.readSync(x.dataId);\n            const rawOutput = this.fourierTransformByMatmul(data, n, inverse);\n            const output = backend_util.splitRealAndImagArrays(rawOutput);\n            return tf.complex(output.real, output.imag).as2D(x.shape[0], x.shape[1]);\n        }\n    }\n    isExponentOf2(size) {\n        return (size & size - 1) === 0;\n    }\n    // FFT using Cooley-Tukey algorithm on radix 2 dimensional input.\n    fftRadix2(input, size, inverse) {\n        if (size === 1) {\n            return input;\n        }\n        const data = this.readSync(input.dataId);\n        const half = size / 2;\n        const evenComplex = backend_util.complexWithEvenIndex(data);\n        let evenTensor = tf.complex(evenComplex.real, evenComplex.imag).as1D();\n        const oddComplex = backend_util.complexWithOddIndex(data);\n        let oddTensor = tf.complex(oddComplex.real, oddComplex.imag).as1D();\n        // Recursive call for half part of original input.\n        evenTensor = this.fftRadix2(evenTensor, half, inverse);\n        oddTensor = this.fftRadix2(oddTensor, half, inverse);\n        const e = backend_util.exponents(size, inverse);\n        const exponent = tf.complex(e.real, e.imag).mul(oddTensor);\n        const addPart = evenTensor.add(exponent);\n        const subPart = evenTensor.sub(exponent);\n        const realTensor = tf.real(addPart).concat(tf.real(subPart));\n        const imagTensor = tf.imag(addPart).concat(tf.imag(subPart));\n        return tf.complex(realTensor, imagTensor).as1D();\n    }\n    // Calculate fourier transform by multplying sinusoid matrix.\n    fourierTransformByMatmul(data, size, inverse) {\n        const ret = new Float32Array(size * 2);\n        // TODO: Use matmul instead once it supports complex64 type.\n        for (let r = 0; r < size; r++) {\n            let real = 0.0;\n            let imag = 0.0;\n            for (let c = 0; c < size; c++) {\n                const e = backend_util.exponent(r * c, size, inverse);\n                const term = backend_util.getComplexWithIndex(data, c);\n                real += term.real * e.real - term.imag * e.imag;\n                imag += term.real * e.imag + term.imag * e.real;\n            }\n            if (inverse) {\n                real /= size;\n                imag /= size;\n            }\n            backend_util.assignToTypedArray(ret, real, imag, r);\n        }\n        return ret;\n    }\n    depthToSpace(x, blockSize, dataFormat) {\n        util.assert(dataFormat === 'NHWC', () => `Only NHWC dataFormat supported on CPU for depthToSpace. Got ${dataFormat}`);\n        util.assert(blockSize > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${blockSize}`);\n        const batchSize = x.shape[0];\n        const inputHeight = x.shape[1];\n        const inputWidth = x.shape[2];\n        const inputDepth = x.shape[3];\n        const outputHeight = inputHeight * blockSize;\n        const outputWidth = inputWidth * blockSize;\n        const outputDepth = inputDepth / (blockSize * blockSize);\n        const xValues = this.readSync(x.dataId);\n        const result = new Float32Array(batchSize * outputHeight * outputWidth * outputDepth);\n        let outputIdx = 0;\n        for (let b = 0; b < batchSize; ++b) {\n            for (let h = 0; h < outputHeight; ++h) {\n                const inH = Math.floor(h / blockSize);\n                const offsetH = (h % blockSize);\n                for (let w = 0; w < outputWidth; ++w) {\n                    const inW = Math.floor(w / blockSize);\n                    const offsetW = (w % blockSize);\n                    const offsetD = (offsetH * blockSize + offsetW) * outputDepth;\n                    for (let d = 0; d < outputDepth; ++d) {\n                        const inD = d + offsetD;\n                        const inputIdx = inD + inputDepth * (inW + inputWidth * (inH + inputHeight * b));\n                        result[outputIdx++] = xValues[inputIdx];\n                    }\n                }\n            }\n        }\n        return tf.tensor4d(result, [batchSize, outputHeight, outputWidth, outputDepth]);\n    }\n    broadcastedBinaryOp(a, b, dtype, op) {\n        const newShape = backend_util.assertAndGetBroadcastShape(a.shape, b.shape);\n        const result = tf.buffer(newShape, dtype);\n        const aVals = this.readSync(a.dataId);\n        const bVals = this.readSync(b.dataId);\n        const aBroadcastDims = backend_util.getBroadcastDims(a.shape, newShape);\n        const bBroadcastDims = backend_util.getBroadcastDims(b.shape, newShape);\n        const resVals = result.values;\n        if (aBroadcastDims.length + bBroadcastDims.length === 0) {\n            for (let i = 0; i < resVals.length; ++i) {\n                resVals[i] = op(aVals[i % aVals.length], bVals[i % bVals.length]);\n            }\n        }\n        else {\n            const aBuf = this.bufferSync(a);\n            const bBuf = this.bufferSync(b);\n            for (let i = 0; i < resVals.length; ++i) {\n                const loc = result.indexToLoc(i);\n                const aLoc = loc.slice(-a.rank);\n                aBroadcastDims.forEach(d => aLoc[d] = 0);\n                const aIndex = aBuf.locToIndex(aLoc);\n                const bLoc = loc.slice(-b.rank);\n                bBroadcastDims.forEach(d => bLoc[d] = 0);\n                const bIndex = bBuf.locToIndex(bLoc);\n                resVals[i] = op(aVals[aIndex], bVals[bIndex]);\n            }\n        }\n        return result.toTensor();\n    }\n    broadcastedBinaryComplexOp(a, b, op) {\n        const newShape = backend_util.assertAndGetBroadcastShape(a.shape, b.shape);\n        const realResult = tf.buffer(newShape, 'float32');\n        const imagResult = tf.buffer(newShape, 'float32');\n        const aVals = this.readSync(a.dataId);\n        const bVals = this.readSync(b.dataId);\n        const aBroadcastDims = backend_util.getBroadcastDims(a.shape, newShape);\n        const bBroadcastDims = backend_util.getBroadcastDims(b.shape, newShape);\n        const realVals = realResult.values;\n        const imagVals = imagResult.values;\n        if (aBroadcastDims.length + bBroadcastDims.length === 0) {\n            for (let i = 0; i < realVals.length; i++) {\n                const aIdx = i % aVals.length;\n                const bIdx = i % bVals.length;\n                const result = op(aVals[aIdx * 2], aVals[aIdx * 2 + 1], bVals[bIdx * 2], bVals[bIdx * 2 + 1]);\n                realVals[i] = result.real;\n                imagVals[i] = result.imag;\n            }\n        }\n        else {\n            const aRealBuf = this.bufferSync(this.data.get(a.dataId).complexTensors.real);\n            const bRealBuf = this.bufferSync(this.data.get(b.dataId).complexTensors.real);\n            for (let i = 0; i < realVals.length; i++) {\n                const loc = realResult.indexToLoc(i);\n                const aLoc = loc.slice(-a.rank);\n                aBroadcastDims.forEach(d => aLoc[d] = 0);\n                const aIndex = aRealBuf.locToIndex(aLoc);\n                const bLoc = loc.slice(-b.rank);\n                bBroadcastDims.forEach(d => bLoc[d] = 0);\n                const bIndex = bRealBuf.locToIndex(bLoc);\n                const opResult = op(aVals[aIndex * 2], aVals[aIndex * 2 + 1], bVals[bIndex * 2], bVals[bIndex * 2 + 1]);\n                realVals[i] = opResult.real;\n                imagVals[i] = opResult.imag;\n            }\n        }\n        return this.complex(realResult.toTensor(), imagResult.toTensor());\n    }\n    split(x, sizeSplits, axis) {\n        return split(x, sizeSplits, axis);\n    }\n    dispose() { }\n    floatPrecision() {\n        return 32;\n    }\n    /** Returns the smallest representable number.  */\n    epsilon() {\n        return super.epsilon();\n    }\n    cropAndResize(images, boxes, boxIndex, cropSize, method, extrapolationValue) {\n        const [batch, imageHeight, imageWidth, numChannels] = images.shape;\n        const numBoxes = boxes.shape[0];\n        const [cropHeight, cropWidth] = cropSize;\n        const output = tf.buffer([numBoxes, cropHeight, cropWidth, numChannels], 'float32');\n        const boxVals = this.readSync(boxes.dataId);\n        const boxIndVals = this.readSync(boxIndex.dataId);\n        const imageVals = this.readSync(images.dataId);\n        const inStride = images.strides; // to calculate flat indexes into image\n        const outStride = output.strides; // to calculate flat indexes into output\n        // Reference implementation\n        // tslint:disable-next-line:max-line-length\n        // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op.cc\n        for (let b = 0; b < numBoxes; b++) {\n            const startInd = b * 4;\n            const y1 = boxVals[startInd];\n            const x1 = boxVals[startInd + 1];\n            const y2 = boxVals[startInd + 2];\n            const x2 = boxVals[startInd + 3];\n            const bInd = boxIndVals[b];\n            if (bInd >= batch) {\n                continue;\n            }\n            const heightScale = (cropHeight > 1) ?\n                (y2 - y1) * (imageHeight - 1) / (cropHeight - 1) :\n                0;\n            const widthScale = (cropWidth > 1) ? (x2 - x1) * (imageWidth - 1) / (cropWidth - 1) : 0;\n            for (let y = 0; y < cropHeight; y++) {\n                const yInd = (cropHeight > 1) ?\n                    y1 * (imageHeight - 1) + y * (heightScale) :\n                    0.5 * (y1 + y2) * (imageHeight - 1);\n                if (yInd < 0 || yInd > imageHeight - 1) {\n                    for (let x = 0; x < cropWidth; x++) {\n                        for (let c = 0; c < numChannels; c++) {\n                            const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                            output.values[ind] = extrapolationValue;\n                        }\n                    }\n                    continue;\n                }\n                if (method === 'bilinear') {\n                    const topInd = Math.floor(yInd);\n                    const bottomInd = Math.ceil(yInd);\n                    const yLerp = yInd - topInd;\n                    for (let x = 0; x < cropWidth; x++) {\n                        const xInd = (cropWidth > 1) ?\n                            x1 * (imageWidth - 1) + x * widthScale :\n                            0.5 * (x1 + x2) * (imageWidth - 1);\n                        if (xInd < 0 || xInd > imageWidth - 1) {\n                            for (let c = 0; c < numChannels; c++) {\n                                const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                                output.values[ind] = extrapolationValue;\n                            }\n                            continue;\n                        }\n                        const leftInd = Math.floor(xInd);\n                        const rightInd = Math.ceil(xInd);\n                        const xLerp = xInd - leftInd;\n                        for (let c = 0; c < numChannels; c++) {\n                            let ind = c + leftInd * inStride[2] + topInd * inStride[1] +\n                                bInd * inStride[0];\n                            const topLeft = imageVals[ind];\n                            ind = c + rightInd * inStride[2] + topInd * inStride[1] +\n                                bInd * inStride[0];\n                            const topRight = imageVals[ind];\n                            ind = c + leftInd * inStride[2] + bottomInd * inStride[1] +\n                                bInd * inStride[0];\n                            const bottomLeft = imageVals[ind];\n                            ind = c + rightInd * inStride[2] + bottomInd * inStride[1] +\n                                bInd * inStride[0];\n                            const bottomRight = imageVals[ind];\n                            const top = topLeft + (topRight - topLeft) * xLerp;\n                            const bottom = bottomLeft + (bottomRight - bottomLeft) * xLerp;\n                            ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                            output.values[ind] = top + ((bottom - top) * yLerp);\n                        }\n                    }\n                }\n                else { // method == \"nearest\"\n                    for (let x = 0; x < cropWidth; ++x) {\n                        const xInd = (cropWidth > 1) ?\n                            x1 * (imageWidth - 1) + x * widthScale :\n                            0.5 * (x1 + x2) * (imageWidth - 1);\n                        if (xInd < 0 || xInd > imageWidth - 1) {\n                            for (let c = 0; c < numChannels; c++) {\n                                const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                                output.values[ind] = extrapolationValue;\n                            }\n                            continue;\n                        }\n                        const closestX = Math.round(xInd);\n                        const closestY = Math.round(yInd);\n                        for (let c = 0; c < numChannels; c++) {\n                            const inInd = c + closestX * inStride[2] +\n                                closestY * inStride[1] + bInd * inStride[0];\n                            const outInd = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                            output.values[outInd] = imageVals[inInd];\n                        }\n                    }\n                }\n            }\n        }\n        return output.toTensor();\n    }\n    sparseToDense(sparseIndices, sparseValues, outputShape, defaultValue) {\n        const { sliceRank, numUpdates, sliceSize, strides, outputSize } = backend_util.calculateShapes(sparseValues, sparseIndices, outputShape);\n        const sumDupeIndices = false;\n        return this.scatter(sparseIndices, sparseValues, outputShape, outputSize, sliceSize, numUpdates, sliceRank, strides, defaultValue, sumDupeIndices);\n    }\n    gatherND(x, indices) {\n        const indicesShape = indices.shape;\n        const sliceRank = indicesShape[indicesShape.length - 1];\n        const [resultShape, numSlices, sliceSize, strides] = backend_util.prepareAndValidate(x, indices);\n        if (numSlices === 0) {\n            return tf.tensor([], resultShape, x.dtype);\n        }\n        const buffer = new TensorBuffer([numSlices, sliceSize], x.dtype);\n        const indicesData = this.readSync(indices.dataId);\n        const xData = this.readSync(x.dataId);\n        for (let i = 0; i < numSlices; i++) {\n            const index = [];\n            let flattenIndex = 0;\n            for (let j = 0; j < sliceRank; j++) {\n                const dim = indicesData[i * sliceRank + j];\n                flattenIndex += dim * strides[j];\n                index.push(dim);\n            }\n            if (flattenIndex < 0 || flattenIndex >= x.size / sliceSize) {\n                throw new Error(`Invalid indices: ${index} does not index into ${x.shape}`);\n            }\n            for (let k = 0; k < sliceSize; k++) {\n                buffer.values[i * sliceSize + k] = xData[flattenIndex * sliceSize + k];\n            }\n        }\n        return buffer.toTensor().reshape(resultShape);\n    }\n    scatterND(indices, updates, shape) {\n        const { sliceRank, numUpdates, sliceSize, strides, outputSize } = backend_util.calculateShapes(updates, indices, shape);\n        const defaultValue = tf.scalar(0);\n        const sumDupeIndices = true;\n        return this.scatter(indices, updates, shape, outputSize, sliceSize, numUpdates, sliceRank, strides, defaultValue, sumDupeIndices);\n    }\n    fill(shape, value, dtype) {\n        dtype = dtype || util.inferDtype(value);\n        const values = util.getArrayFromDType(dtype, util.sizeFromShape(shape));\n        values.fill(value);\n        return engine().makeTensor(values, shape, dtype, this);\n    }\n    onesLike(x) {\n        if (x.dtype === 'string') {\n            throw new Error('onesLike is not supported for string tensors');\n        }\n        else {\n            return this.fill(x.shape, 1, x.dtype);\n        }\n    }\n    zerosLike(x) {\n        const values = util.getArrayFromDType(x.dtype, util.sizeFromShape(x.shape));\n        return this.makeOutput(values, x.shape, x.dtype);\n    }\n    linspace(start, stop, num) {\n        return backend_util.linspaceImpl(start, stop, num);\n    }\n    scatter(indices, updates, shape, outputSize, sliceSize, numUpdates, sliceRank, strides, defaultValue, sumDupeIndices) {\n        const flattenShape = [outputSize / sliceSize, sliceSize];\n        const indicesData = this.readSync(indices.dataId);\n        const updatesData = this.readSync(updates.dataId);\n        if (outputSize === 0) {\n            return tf.tensor([], shape, updates.dtype);\n        }\n        const buffer = new TensorBuffer(flattenShape, updates.dtype);\n        buffer.values.fill(this.readSync(defaultValue.dataId)[0]);\n        for (let i = 0; i < numUpdates; i++) {\n            const index = [];\n            let flattenIndex = 0;\n            for (let j = 0; j < sliceRank; j++) {\n                const dim = indicesData[i * sliceRank + j];\n                index.push(dim);\n                flattenIndex += dim * strides[j];\n            }\n            if (flattenIndex < 0 || flattenIndex >= outputSize / sliceSize) {\n                throw new Error(`Invalid indices: ${index} does not index into ${shape}`);\n            }\n            for (let k = 0; k < sliceSize; k++) {\n                if (sumDupeIndices) {\n                    buffer.values[flattenIndex * sliceSize + k] +=\n                        updatesData[i * sliceSize + k];\n                }\n                else {\n                    buffer.values[flattenIndex * sliceSize + k] = updates.rank === 0 ?\n                        updatesData[0] :\n                        updatesData[i * sliceSize + k];\n                }\n            }\n        }\n        return buffer.toTensor().reshape(shape);\n    }\n}\n//# sourceMappingURL=backend_cpu.js.map"]},"metadata":{},"sourceType":"module"}